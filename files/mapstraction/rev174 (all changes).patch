Index: mapstraction.js
===================================================================
--- mapstraction.js	(revision 174)
+++ mapstraction.js	(working copy)
@@ -1,3 +1,5 @@
+(function(){
+
 /*
    Copyright (c) 2006-7, Tom Carden, Steve Coast, Mikel Maron, Andrew Turner, Henri Bergius
    All rights reserved.
@@ -21,17 +23,19 @@
 ///////////////////////////
 
 /**
- * $, the dollar function, elegantising getElementById()
- * @returns an element
+ * $m, the dollar function, elegantising getElementById()
+ * @return An HTML element or array of HTML elements
  */
 function $m() {
-  var elements = new Array();
+  var elements = [];
   for (var i = 0; i < arguments.length; i++) {
     var element = arguments[i];
-    if (typeof element == 'string')
+    if (typeof(element) == 'string') {
       element = document.getElementById(element);
-    if (arguments.length == 1)
+    }
+    if (arguments.length == 1) {
       return element;
+    }
     elements.push(element);
   }
   return elements;
@@ -39,21 +43,28 @@
 
 /**
  * loadScript is a JSON data fetcher 
+ * @param {String} src URL to JSON file
+ * @param {Function} callback Callback function
  */
-function loadScript(src,callback) {
+function loadScript(src, callback) {
   var script = document.createElement('script');
   script.type = 'text/javascript';
   script.src = src;
   if (callback) {
-    var evl=new Object();
-    evl.handleEvent=function (e){callback();};
-    script.addEventListener('load',evl,true);
+    var evl = {};
+    evl.handleEvent = function(e) { callback(); };
+    script.addEventListener('load' ,evl ,true);
   }
-  document.getElementsByTagName("head")[0].appendChild(script);
+  document.getElementsByTagName('head')[0].appendChild(script);
   return;
 }
 
-function convertLatLonXY_Yahoo(point,level){ //Mercator
+/**
+ * 
+ * @param {Object} point
+ * @param {Object} level
+ */
+function convertLatLonXY_Yahoo(point, level) { //Mercator
   var size = 1 << (26 - level);
   var pixel_per_degree = size / 360.0;
   var pixel_per_radian = size / (2 * Math.PI);
@@ -65,64 +76,88 @@
   return answer;
 }
 
-
-
 /**
- *
+ * Load a stylesheet from a remote file.
+ * @param {String} href URL to the CSS file
  */
 function loadStyle(href) {
   var link = document.createElement('link');
   link.type = 'text/css';
   link.rel = 'stylesheet';
   link.href = href;
-  document.getElementsByTagName("head")[0].appendChild(link);
+  document.getElementsByTagName('head')[0].appendChild(link);
   return;
 }
 
-
 /**
  * getStyle provides cross-browser access to css
+ * @param {Object} el HTML Element
+ * @param {String} prop Style property name
  */
 function getStyle(el, prop) {
   var y;
-  if (el.currentStyle) 
+  if (el.currentStyle) {
     y = el.currentStyle[prop];
-  else if (window.getComputedStyle)
+  }
+  else if (window.getComputedStyle) {
     y = window.getComputedStyle( el, '').getPropertyValue(prop);
+  }
   return y;
 }
 
-// longitude to metres
-// http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM
-// "A degree of longitude at the equator is 111.2km... For other latitudes,
-// multiply by cos(lat)"
-// assumes the earth is a sphere but good enough for our purposes
 
-function lonToMetres (lon,lat) {
-  return lon * 111200 * Math.cos(lat * (Math.PI/180));
+/**
+ * Convert longitude to metres
+ * http://www.uwgb.edu/dutchs/UsefulData/UTMFormulas.HTM
+ * "A degree of longitude at the equator is 111.2km... For other latitudes,
+ * multiply by cos(lat)"
+ * assumes the earth is a sphere but good enough for our purposes
+ * @param {Float} lon
+ * @param {Float} lat
+ */
+function lonToMetres(lon, lat) {
+  return lon * (111200 * Math.cos(lat * (Math.PI / 180)));
 }
 
-function metresToLon(m,lat) {
-  return m / (111200*Math.cos(lat * (Math.PI/180)));
+/**
+ * Convert metres to longitude
+ * @param {Object} m
+ * @param {Object} lat
+ */
+function metresToLon(m, lat) {
+  return m / (111200 * Math.cos(lat * (Math.PI / 180)));
 }
 
+
 // stuff to convert google zoom levels to/from degrees
 // assumes zoom 0 = 256 pixels = 360 degrees
 //         zoom 1 = 256 pixels = 180 degrees
 // etc.
 
-function getDegreesFromGoogleZoomLevel (pixels,zoom)
-{
-  return (360*pixels) / (Math.pow(2,zoom+8));
+/**
+ * 
+ * @param {Object} pixels
+ * @param {Object} zoom
+ */
+function getDegreesFromGoogleZoomLevel(pixels, zoom) {
+  return (360 * pixels) / (Math.pow(2, zoom + 8));
 }
 
-function getGoogleZoomLevelFromDegrees (pixels,degrees)
-{
-  return logN ((360*pixels)/degrees, 2) - 8;
+/**
+ * 
+ * @param {Object} pixels
+ * @param {Object} degrees
+ */
+function getGoogleZoomLevelFromDegrees(pixels, degrees) {
+  return logN((360 * pixels) / degrees, 2) - 8;
 }
 
-function logN (number,base)
-{
+/**
+ * 
+ * @param {Object} number
+ * @param {Object} base
+ */
+function logN(number, base) {
   return Math.log(number) / Math.log(base);
 }
 
@@ -142,42 +177,39 @@
  */
 function Mapstraction(element,api,debug) {
   this.api = api; // could detect this from imported scripts?
-  this.maps = new Object();
+  this.maps = {};
   this.currentElement = $m(element);
-  this.eventListeners = new Array();
-  this.markers = new Array();
-  this.layers = new Array();
-  this.polylines = new Array();
-  this.images = new Array();
-  this.loaded = new Object();
-  this.onload = new Object();
-
+  this.eventListeners = [];
+  this.markers = [];
+  this.layers = [];
+  this.polylines = [];
+  this.images = [];
+  this.loaded = {};
+  this.onload = {};
+	
   // Mapstraction.writeInclude(api, "nothing");
-  
+	
   // optional debug support
-  if(debug == true)
-  {
-    this.debug = true
+  if (debug === true) {
+    this.debug = true;
+  } 
+  else {
+    this.debug = false;
   }
-  else
-  {
-    this.debug = false
-  }
 
   // This is so that it is easy to tell which revision of this file 
   // has been copied into other projects.
   this.svn_revision_string = '$Revision$';
-  this.addControlsArgs = new Object();
-  
-  if (this.currentElement)
-  {
-    this.addAPI($m(element),api);
-  }
+  this.addControlsArgs = {};
+	
+  if (this.currentElement) {
+    this.addAPI($m(element), api);
+  }	
 }
 
 
 /**
- * swap will change the current api on the fly
+ * Change the current api on the fly
  * @param {String} api The API to swap to
  */
 Mapstraction.prototype.swap = function(element,api) {
@@ -196,19 +228,20 @@
 
   this.api = api;
 
-  if (this.maps[this.api] == undefined) {
+  if (this.maps[this.api] === undefined) {
     this.addAPI($m(element),api);
 
     this.setCenterAndZoom(center,zoom);
 
-    for (var i=0; i<this.markers.length; i++) {
-      this.addMarker( this.markers[i], true); 
+    for (var i = 0; i < this.markers.length; i++) {
+      this.addMarker(this.markers[i], true);
     }
 
-    for (var i=0; i<this.polylines.length; i++) {
-      this.addPolyline( this.polylines[i], true); 
+    for (var j = 0; j < this.polylines.length; j++) {
+      this.addPolyline( this.polylines[j], true); 
     }
-  }else{
+  }
+  else {
 
     //sync the view
     this.setCenterAndZoom(center,zoom);
@@ -219,22 +252,26 @@
 
   this.addControls(this.addControlsArgs);
 
+};
 
-}
-
+/**
+ * 
+ * @param {Object} element
+ * @param {String} api
+ */
 Mapstraction.prototype.addAPI = function(element,api) { 
   me = this;
   this.loaded[api] = false;
-  this.onload[api] = new Array();    
+  this.onload[api] = [];	
 
   switch (api) {
     case 'yahoo':
       if (YMap) {
         this.maps[api] = new YMap(element);
-
-        YEvent.Capture(this.maps[api],EventsList.MouseClick,function(event,location) { me.clickHandler(location.Lat,location.Lon,location,me) });
-        YEvent.Capture(this.maps[api],EventsList.changeZoom,function() { me.moveendHandler(me) });
-        YEvent.Capture(this.maps[api],EventsList.endPan,function() { me.moveendHandler(me) });
+        
+        YEvent.Capture(this.maps[api], EventsList.MouseClick, function(event,location) { me.clickHandler(location.Lat, location.Lon, location, me); });
+        YEvent.Capture(this.maps[api], EventsList.changeZoom, function() { me.moveendHandler(me); });
+        YEvent.Capture(this.maps[api], EventsList.endPan, function() { me.moveendHandler(me); });
         this.loaded[api] = true;
       }
       else {
@@ -254,7 +291,7 @@
               }
               });
 
-          GEvent.addListener(this.maps[api], 'moveend', function() {me.moveendHandler(me)});
+          GEvent.addListener(this.maps[api], 'moveend', function() { me.moveendHandler(me); });
           this.loaded[api] = true;
         }
         else {
@@ -276,16 +313,18 @@
         var ffv = 0;
         var ffn = "Firefox/";
         var ffp = navigator.userAgent.indexOf(ffn);
-        if (ffp != -1) ffv = parseFloat(navigator.userAgent.substring(ffp+ffn.length));
+        if (ffp != -1) {
+          ffv = parseFloat(navigator.userAgent.substring(ffp+ffn.length));
+        } 
         if (ffv >= 1.5) {
-          Msn.Drawing.Graphic.CreateGraphic=function(f,b) { return new Msn.Drawing.SVGGraphic(f,b) }
+          Msn.Drawing.Graphic.CreateGraphic = function(f,b) { return new Msn.Drawing.SVGGraphic(f, b); };
         }
 
         this.maps[api] = new VEMap(element.id);
         this.maps[api].LoadMap();
 
         this.maps[api].AttachEvent("onclick", function(e) { me.clickHandler(e.view.LatLong.Latitude, e.view.LatLong.Longitude, me); });
-        this.maps[api].AttachEvent("onchangeview", function(e) {me.moveendHandler(me)});
+        this.maps[api].AttachEvent("onchangeview", function(e) {me.moveendHandler(me);});
 
         //Source of our trouble with Mapufacture?
         this.resizeTo(msft_width, msft_height);
@@ -304,7 +343,7 @@
           maxResolution:156543, numZoomLevels:18, units:'meters', projection: "EPSG:41001"
         }
       );
-       
+      
       this.layers['osmmapnik'] = new OpenLayers.Layer.TMS(
         'OSM Mapnik', 
         [    
@@ -385,7 +424,7 @@
               }
               });
 
-          GEvent.addListener(this.maps[api], 'moveend', function() {me.moveendHandler(me)});
+          GEvent.addListener(this.maps[api], 'moveend', function() {me.moveendHandler(me);});
 
           // Add OSM tiles
 
@@ -393,13 +432,13 @@
           var copyrightCollection = new GCopyrightCollection('OSM'); 
           copyrightCollection.addCopyright(copyright); 
 
-          var tilelayers = new Array(); 
+          var tilelayers = []; 
           tilelayers[0] = new GTileLayer(copyrightCollection, 1, 18); 
           tilelayers[0].getTileUrl = function (a, b) {
             return "http://tile.openstreetmap.org/"+b+"/"+a.x+"/"+a.y+".png";
           };
           tilelayers[0].isPng = function() { return true;};
-          tilelayers[0].getOpacity = function() { return 1.0; }          
+          tilelayers[0].getOpacity = function() { return 1.0; };
           
           var custommap = new GMapType(tilelayers, new GMercatorProjection(19), "OSM", {errorMessage:"More OSM coming soon"}); 
           this.maps[api].addMapType(custommap); 
@@ -423,20 +462,43 @@
 
       break;
     case 'multimap':
-      this.maps[api] = new MultimapViewer( element );
+	 	
+      if (MultimapViewer) {
+	  		
+        if(this.debug){
+          // multimap calls this print_debug function to output debug info
+          window.print_debug = function(strMessage){
+            var dbg = document.getElementById('debug');
+            if(dbg){
+              dbg.innerHTML += '<p>MUlTIMAP: ' + strMessage + '</p>';
+            }
+            else {
+              alert(strMessage);
+            }
 
-      this.maps[api].addEventHandler( 'click', function(eventType, eventTarget, arg1, arg2, arg3) {
+          };
+        }
+			
+        this.maps[api] = new MultimapViewer(element);
+	  	
+        this.maps[api].addEventHandler('click', function(eventType, eventTarget, arg1, arg2, arg3){
           if (arg1) {
-          me.clickHandler(arg1.lat, arg1.lon, me);
+            me.clickHandler(arg1.lat, arg1.lon, me);
           }
-          });
-      this.maps[api].addEventHandler( 'changeZoom', function(eventType, eventTarget, arg1, arg2, arg3) {
+        });
+        this.maps[api].addEventHandler('changeZoom', function(eventType, eventTarget, arg1, arg2, arg3){
           me.moveendHandler(me);
-          });
-      this.maps[api].addEventHandler( 'endPan', function(eventType, eventTarget, arg1, arg2, arg3) {
+        });
+        this.maps[api].addEventHandler('endPan', function(eventType, eventTarget, arg1, arg2, arg3){
           me.moveendHandler(me);
-          });
-      this.loaded[api] = true;
+        });	  	
+        this.loaded[api] = true;
+	  	
+      }
+      else {
+        alert('Multimap map script not imported');
+      }
+		
       break;
     case 'map24':
       // Copied from Google and modified
@@ -506,14 +568,13 @@
       }
       break;
     case 'mapquest':
-      myself = this;
       MQInitOverlays( function() {
-          myself.loaded[api] = true;
-          myself.maps[api] = new MQTileMap(element);
-          for (var i = 0; i < myself.onload[api].length; i++) {
-              myself.onload[api][i]();
-          }
-          });
+        me.loaded[api] = true;
+        me.maps[api] = new MQTileMap(element);
+        for (var i = 0; i < me.onload[api].length; i++) {
+          me.onload[api][i]();
+        }
+      });
 
       // MQEventManager.addListener(this.maps[api],"click",function(event,location) { me.clickHandler(location.Lat,location.Lon,location,me) });
       // MQEventManager.addListener(this.maps[api],"zoomend",function() { me.moveendHandler(me) });
@@ -521,19 +582,19 @@
       break;
     case 'freeearth':
       this.maps[api] = new FE.Map($m(element));
-      myself = this;
       this.maps[api].onLoad = function() {
-        myself.freeEarthLoaded = true;
-        myself.loaded[api] = true;
-        for (var i = 0; i < myself.onload[api].length; i++) {
-          myself.onload[api][i]();
+        me.freeEarthLoaded = true;
+        me.loaded[api] = true;
+        for (var i = 0; i < me.onload[api].length; i++) {
+          me.onload[api][i]();
         }
-      }
+      };
       this.maps[api].load();
-      break;    
+      break;	
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(api + ' not supported by mapstraction');
+      }        
   }
 
 
@@ -543,119 +604,121 @@
   // FIXME: test if google/yahoo etc need this resize called. Also - getStyle returns
   // CSS size ('200px') not an integer, and resizeTo seems to expect ints
 
-}
+};
 
-Mapstraction._getScriptLocation=function(){
-  var scriptLocation="";
-  var SCRIPT_NAME = "mapstraction.js";
-  var scripts=document.getElementsByTagName('script');
+Mapstraction._getScriptLocation = function() {
+  var scriptLocation = '';
+  var SCRIPT_NAME = 'mapstraction.js';
+  var scripts = document.getElementsByTagName('script');
   for(var i=0; i<scripts.length; i++) {
-    var src=scripts[i].getAttribute('src');
+    var src = scripts[i].getAttribute('src');
     if(src) { 
-      var index=src.lastIndexOf(SCRIPT_NAME);
-      if((index>-1)&&(index+SCRIPT_NAME.length==src.length)){scriptLocation=src.slice(0,-SCRIPT_NAME.length);
+      var index = src.lastIndexOf(SCRIPT_NAME);
+      if((index > -1) && (index + SCRIPT_NAME.length == src.length)) {
+        scriptLocation=src.slice(0, -SCRIPT_NAME.length);
         break;
       }
     }
   }
   return scriptLocation;
-}
+};
+
 Mapstraction.writeInclude = function(api, key, version) {
-
-  var jsfiles=new Array();
-  var allScriptTags="";
-  var host=Mapstraction._getScriptLocation()+"lib/";
+  var jsfiles = [];
+  var allScriptTags = '';
+  var host = Mapstraction._getScriptLocation() + 'lib/';
   switch(api) {
     case 'google': 
-      if(version == null) { version = "2"; }
+      if(version === null) { version = '2'; }
       jsfiles.push('http://maps.google.com/maps?file=api&v=' + version + '&key=' + key);
       break;
-    case "microsoft":
-      if(version == null) { version = "v3"; }    
+    case 'microsoft':
+      if(version === null) { version = 'v3'; }    
       jsfiles.push('http://dev.virtualearth.net/mapcontrol/' + version + '/mapcontrol.js');
-        break;
-    case "yahoo":
-      if(version == null) { version = "3.0"; }    
+      break;
+    case 'yahoo':
+      if(version === null) { version = '3.0'; }    
       jsfiles.push('http://api.maps.yahoo.com/ajaxymap?v='+ version + '&appid=' + key);
-        break;
-    case "openlayers": 
+      break;
+    case 'openlayers':
       jsfiles.push('http://openlayers.org/api/OpenLayers.js');
       break;
-    case "multimap": 
-      if(version == null) { version = "1.2"; }
+    case 'multimap':
+      if(version === null) { version = '1.2'; }
       jsfiles.push('http://developer.multimap.com/API/maps/' + version + '/' + key);
-        break;
+      break;
     case "map24": 
       jsfiles.push('http://api.maptp.map24.com/ajax?appkey=' + key);
-        break;
+      break;
     case "mapquest": 
-      if(version == null) { version = "5.1"; }
-    
+      if(version === null) { version = "5.1"; }
       jsfiles.push('http://btilelog.access.mapquest.com/tilelog/transaction?transaction=script&key=' + key + '&ipr=true&itk=true&v=' + version);
       jsfiles.push('mapquest-js/mqcommon.js');
       jsfiles.push('mapquest-js/mqutils.js');
       jsfiles.push('mapquest-js/mqobjects.js');
       jsfiles.push('mapquest-js/mqexec.js');
-        break;
-        case "freeearth": 
+      break;
+    case "freeearth": 
       jsfiles.push('http://freeearth.poly9.com/api.js');
+  }
+  
+  for(var i=0; i<jsfiles.length; i++) {
+    if(/MSIE/.test(navigator.userAgent) || /Safari/.test(navigator.userAgent)) { 
+      // var currentScriptTag="<script src='"+host+jsfiles[i]+"'></script>";
+      var currentScriptTag = jsfiles[i];
+      allScriptTags += currentScriptTag;
     }
-    
-    for(var i=0; i<jsfiles.length; i++) {
-      if(/MSIE/.test(navigator.userAgent)||/Safari/.test(navigator.userAgent)) { 
-        // var currentScriptTag="<script src='"+host+jsfiles[i]+"'></script>";
-        var currentScriptTag = jsfiles[i];
-        allScriptTags += currentScriptTag;
-      } else {
-        var s=document.createElement("script");
-        s.src=jsfiles[i];
-        s.type="text/javascript";
-        var h=document.getElementsByTagName("head").length ? document.getElementsByTagName("head")[0] : document.body;
-        h.appendChild(s);
+    else {
+      var s = document.createElement('script');
+      s.src = jsfiles[i];
+      s.type = 'text/javascript';
+      var h = document.getElementsByTagName('head').length ? document.getElementsByTagName('head')[0] : document.body;
+      h.appendChild(s);
     }
   }
-  if(allScriptTags) document.write(allScriptTags);
+  if(allScriptTags) {
+    document.write(allScriptTags);
+  }
     
-}
+};
 
-/* Returns the loaded state of a Map Provider
- *
+/**
+ * Returns the loaded state of a Map Provider
  * @param {String} api Optional API to query for. If not specified, returns state of the originally created API
- * @returns the state of the map loading
- * @type Boolean
+ * @type {Boolean} The state of the map loading
  */
-  Mapstraction.prototype.isLoaded = function(api){
-    if(api == null)
-      api = this.api;
-
-    return this.loaded[api];
+Mapstraction.prototype.isLoaded = function(api){
+  if (api === null) {
+    api = this.api;
   }
+  return this.loaded[api];
+};
 
-/* Set the debugging on or off - shows alert panels for functions that don't exist in Mapstraction
- * 
- * @param {Bool} debug true to turn on debugging, false to turn it off
- * @returns the state of debugging
- * @type Boolean
+/**
+ * Set the debugging on or off - shows alert panels for functions that don't exist in Mapstraction
+ * @param {Boolean} debug true to turn on debugging, false to turn it off
+ * @type {Boolean} The state of debugging
  */
-  Mapstraction.prototype.setDebug = function(debug){
-    if(debug != null)
-      return this.debug = debug;
-    else
-      return this.debug;
+Mapstraction.prototype.setDebug = function(debug){
+  if(debug !== null) {
+    this.debug = debug;
   }
+  return this.debug;
+};
 
-/* Resize the current map to the specified width and height
+
+/**
+ * Resize the current map to the specified width and height
  * (since it is actually on a child div of the mapElement passed
  * as argument to the Mapstraction constructor, the resizing of this
  * mapElement may have no effect on the size of the actual map)
- * 
- * @param {int} width The width the map should be.
- * @param {int} height The width the map should be.
+ * @param {Integer} width The width the map should be.
+ * @param {Integer} height The width the map should be.
  */
 Mapstraction.prototype.resizeTo = function(width,height){
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.resizeTo(width,height); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.resizeTo(width,height); } );
     return;
   }
 
@@ -691,43 +754,76 @@
       Map24.MapApplication.Map.Canvas['c'].resizeTo(width,height);
       break;
   }
-}
+};
 
 /////////////////////////
 // 
 // Event Handling
 //
+// FIXME need to consolidate some of these handlers...
+//
 ///////////////////////////
 
-Mapstraction.prototype.clickHandler = function(lat,lon, me) { //FIXME need to consolidate some of these handlers... 
-  for(var i = 0; i < this.eventListeners.length; i++) {
-    if(this.eventListeners[i][1] == 'click') {
-      this.eventListeners[i][0](new LatLonPoint(lat,lon));
-    }
-  }
-}
+// Click handler attached to native API
+Mapstraction.prototype.clickHandler = function(lat, lon, me) {
+  this.callEventListeners('click', { location: new LatLonPoint(lat, lon) });
+};
 
+// Move and zoom handler attached to native API
 Mapstraction.prototype.moveendHandler = function(me) {
+  this.callEventListeners('moveend', {});
+};
+
+/**
+ * Add a listener for an event.
+ * @param {String} type Event type to attach listener to
+ * @param {Function} func Callback function
+ * @param {Object} caller Callback object
+ */
+Mapstraction.prototype.addEventListener = function() {
+	var listener = {};
+	listener.event_type = arguments[0];
+ 	listener.callback_function = arguments[1];
+	
+	// added the calling object so we can retain scope of callback function
+	if(arguments.length == 3) {
+		listener.back_compat_mode = false;
+		listener.callback_object = arguments[2];
+	}
+	else {
+		listener.back_compat_mode = true;
+		listener.callback_object = null;
+	}
+	this.eventListeners.push(listener);
+};
+
+/**
+ * Call listeners for a particular event.
+ * @param {String} sEventType Call listeners of this event type
+ * @param {Object} oEventArgs Event args object to pass back to the callback
+ */
+Mapstraction.prototype.callEventListeners = function(sEventType, oEventArgs) {
+  oEventArgs.source = this;
   for(var i = 0; i < this.eventListeners.length; i++) {
-    if(this.eventListeners[i][1] == 'moveend') {
-      this.eventListeners[i][0]();
+    var evLi = this.eventListeners[i];
+    if(evLi.event_type == sEventType) {
+      // only two cases for this, click and move
+      if(evLi.back_compat_mode) {
+        if(evLi.event_type == 'click') {
+          evLi.callback_function(oEventArgs.location);
+        }
+        else {
+          evLi.callback_function();
+        }
+      }
+      else {
+        var scope = evLi.callback_object || this;
+        evLi.callback_function.call(scope, oEventArgs);
+      }
     }
   }
-}
+};
 
-Mapstraction.prototype.addEventListener = function(type, func) {
-  var listener = new Array();
-  listener.push(func);
-  listener.push(type);
-  this.eventListeners.push(listener);
-
-  switch (this.api) {
-    case 'openlayers':
-        this.maps[this.api].events.register(type, this, func);
-        break;
-  }
-}
-
 ////////////////////
 //
 // map manipulation
@@ -751,9 +847,9 @@
  * @param {args} array Which controls to switch on
  */
 Mapstraction.prototype.addControls = function( args ) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.addControls(args); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.addControls(args); } );
     return;
   }
 
@@ -767,17 +863,18 @@
     case 'openstreetmap':
       //remove old controls
       if (this.controls) {
-        while (ctl = this.controls.pop()) {
+        while ((ctl = this.controls.pop())) {
           map.removeControl(ctl);
         }
-      } else {
-        this.controls = new Array();
       }
+      else {
+        this.controls = [];
+      }
       c = this.controls;
 
       // Google has a combined zoom and pan control.
-      if ( args.zoom || args.pan ) {
-        if ( args.zoom == 'large' ) {
+      if (args.zoom || args.pan) {
+        if (args.zoom == 'large') {
           c.unshift(new GLargeMapControl());
           map.addControl(c[0]);
         } else {
@@ -785,20 +882,30 @@
           map.addControl(c[0]);
         }
       }
-      if ( args.scale    ) { c.unshift(new GScaleControl()); map.addControl(c[0]); }
+      if (args.scale) { c.unshift(new GScaleControl()); map.addControl(c[0]); }
 
-      if (this.api != "openstreetmap") {     
-        if ( args.overview ) { c.unshift(new GOverviewMapControl()); map.addControl(c[0]); }
-        if ( args.map_type ) { c.unshift(new GMapTypeControl()); map.addControl(c[0]); }
+      if (this.api != "openstreetmap") {	 
+        if (args.overview) { c.unshift(new GOverviewMapControl()); map.addControl(c[0]); }
+        if (args.map_type) { c.unshift(new GMapTypeControl()); map.addControl(c[0]); }
       }
       break;
 
     case 'yahoo':
-      if ( args.pan             ) map.addPanControl();
-      else map.removePanControl();
-      if ( args.zoom == 'large' ) map.addZoomLong();
-      else if ( args.zoom == 'small' ) map.addZoomShort();
-      else map.removeZoomScale();
+      if (args.pan) {
+        map.addPanControl();
+      } 
+      else {
+        map.removePanControl();
+      }
+      if (args.zoom == 'large') {
+        map.addZoomLong();
+      } 
+      else if ( args.zoom == 'small' ) {
+        map.addZoomShort();
+      } 
+      else {
+        map.removeZoomScale();
+      }
       break;
 
     case 'openlayers':
@@ -812,36 +919,38 @@
       else {  }
       if ( args.zoom == 'large' )      { map.addControl(new OpenLayers.Control.PanZoomBar());}
       else if ( args.zoom == 'small' ) { map.addControl(new OpenLayers.Control.ZoomBox());}
-      else map.addControl(new OpenLayers.Control.ZoomBox());
+      else { map.addControl(new OpenLayers.Control.ZoomBox()); }
       if ( args.overview ) { map.addControl(new OpenLayers.Control.OverviewMap()); }
       if ( args.map_type ) { map.addControl(new OpenLayers.Control.LayerSwitcher()); }
       break;
+
     case 'multimap':
       //FIXME -- removeAllWidgets();  -- can't call addControls repeatedly
 
-      pan_zoom_widget = "MM";
+      pan_zoom_widget = 'MM';
       if (args.zoom && args.zoom == "small") { pan_zoom_widget = pan_zoom_widget + "Small"; }
       if (args.pan) { pan_zoom_widget = pan_zoom_widget + "Pan"; }
       if (args.zoom) { pan_zoom_widget = pan_zoom_widget + "Zoom"; }
       pan_zoom_widget = pan_zoom_widget + "Widget";
 
       if (pan_zoom_widget != "MMWidget") {
-        eval(" map.addWidget( new " + pan_zoom_widget + "() );");
+        eval(' map.addWidget( new ' + pan_zoom_widget + '() );');
       } 
 
       if ( args.map_type ) { map.addWidget( new MMMapTypeWidget() ); }
-      if ( args.overview ) { map.addWidget( new MMOverviewWidget() ); }            
+      if ( args.overview ) { map.addWidget( new MMOverviewWidget() ); }			
       break;
 
     case 'mapquest':
       //remove old controls
       if (this.controls) {
-        while (ctl = this.controls.pop()) {
+        while ( (ctl = this.controls.pop()) ) {
           map.removeControl(ctl);
         }
-      } else {
-        this.controls = new Array();
       }
+      else {
+        this.controls = [];
+      }
       c = this.controls;
 
       if ( args.pan ) { c.unshift(new MQPanControl()); map.addControl(c[0], new MQMapCornerPlacement(MQMapCorner.TOP_LEFT, new MQSize(0,0))); }
@@ -852,7 +961,7 @@
       if ( args.map_type ) { c.unshift(new MQViewControl()); map.addControl(c[0], new MQMapCornerPlacement(MQMapCorner.TOP_RIGHT, new MQSize(0,0))); }
       break;
   }
-}
+};
 
 
 /**
@@ -860,9 +969,9 @@
  * Supported by: yahoo, google, openstreetmap, openlayers, multimap, mapquest
  */
 Mapstraction.prototype.addSmallControls = function() {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.addSmallControls(); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.addSmallControls(); } );
     return;
   }
 
@@ -895,19 +1004,18 @@
       map.addControl(new PanControl(map));
       this.addControlsArgs.pan = true; 
       this.addControlsArgs.zoom = 'small';
-
       break;
   }
-}
+};
 
 /**
- * addLargeControls adds a map panning control and zoom bar to the map
+ * addLargeControls adds a small map panning control and zoom buttons to the map
  * Supported by: yahoo, google, openstreetmap, multimap, mapquest
  */
 Mapstraction.prototype.addLargeControls = function() {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.addLargeControls(); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.addLargeControls(); } );
     return;
   }
 
@@ -928,6 +1036,7 @@
       map.addControl(new GOverviewMapControl()) ;
       this.addControlsArgs.overview = true; 
       this.addControlsArgs.map_type = true;
+      // no break statement here intentionally
     case 'openstreetmap':
       map.addControl(new GLargeMapControl());
       map.addControl(new GScaleControl()) ;
@@ -950,16 +1059,16 @@
       this.addControlsArgs.map_type = true; 
       break;
   }
-}
+};
 
 /**
  * addMapTypeControls adds a map type control to the map (streets, aerial imagery etc)
  * Supported by: yahoo, google, openstreetmap, multimap, mapquest
  */
 Mapstraction.prototype.addMapTypeControls = function() {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.addMapTypeControls(); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.addMapTypeControls(); } );
     return;
   }
 
@@ -983,19 +1092,17 @@
       map.addControl( new OpenLayers.Control.LayerSwitcher({'ascending':false}) );
       break;      
   }
-}
+};
 
 /**
- * dragging
- *  enable/disable dragging of the map
- *  (only implemented for yahoo and google)
+ * Enable/disable dragging of the map
  * Supported by: yahoo, google, openstreetmap, multimap
- * @param {on} on Boolean
+ * @param {Boolean} on 
  */
 Mapstraction.prototype.dragging = function(on) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.dragging(on); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.dragging(on); } );
     return;
   }
 
@@ -1028,17 +1135,17 @@
       map.enableDragging(on);
       break;
   }
-}
+};
 
 /**
- * centers the map to some place and zoom level
+ * Centers the map to some place and zoom level
  * @param {LatLonPoint} point Where the center of the map should be
- * @param {int} zoom The zoom level where 0 is all the way out.
+ * @param {Integer} zoom The zoom level where 0 is all the way out.
  */
 Mapstraction.prototype.setCenterAndZoom = function(point, zoom) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.setCenterAndZoom(point, zoom); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.setCenterAndZoom(point, zoom); } );
     return;
   }
   var map = this.maps[this.api];
@@ -1059,16 +1166,14 @@
       map.setCenter(point.toOpenLayers(), zoom);
       break;
     case 'multimap':
-      map.goToPosition( new MMLatLon( point.lat, point.lng ) );
-      map.setZoomFactor( zoom );
+      map.goToPosition( new MMLatLon( point.lat, point.lng ), zoom );
       break;
     case 'map24':
-      var newSettings = new Object();
+      var newSettings = {};
       newSettings.Latitude = point.lat*60;
       newSettings.Longitude = point.lon*60;
       var client = map.MapClient['Static'];
-      var dLon = getDegreesFromGoogleZoomLevel 
-        (client.getCanvasSize().Width,zoom);
+      var dLon = getDegreesFromGoogleZoomLevel(client.getCanvasSize().Width,zoom);
       newSettings.MinimumWidth = lonToMetres (dLon, point.lat);
       Map24.MapApplication.center ( newSettings );
       break;
@@ -1078,33 +1183,35 @@
       break;
     case 'freeearth':
       if (this.freeEarthLoaded) {
-      map.setTargetLatLng( point.toFreeEarth() );
-      } else {
-        myself = this;
-        this.freeEarthOnLoad.push( function() { myself.setCenterAndZoom(point); } );
+        map.setTargetLatLng( point.toFreeEarth() );
+      } 
+	  else {
+        self = this;
+        this.freeEarthOnLoad.push( function() { self.setCenterAndZoom(point); } );
       }
       break;
-      default:
-      if(this.debug)
-  alert(this.api + ' not supported by Mapstraction.setCenterAndZoom');
+    default:
+      if (this.debug) {
+	    alert(this.api + ' not supported by Mapstraction.setCenterAndZoom');
+      }
   }
-}
+};
 
 
 /**
- * addMarker adds a marker pin to the map
+ * Adds a marker pin to the map
  * @param {Marker} marker The marker to add
- * @param {old} old If true, doesn't add this marker to the markers array. Used by the "swap" method
+ * @param {Boolean} old If true, doesn't add this marker to the markers array. Used by the "swap" method
  */
-Mapstraction.prototype.addMarker = function(marker,old) {
+Mapstraction.prototype.addMarker = function(marker, old) {
   var map = this.maps[this.api];
   marker.mapstraction = this;
   marker.api = this.api;
   marker.map = this.maps[this.api];
 
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.addMarker(marker, old); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.addMarker(marker, old); } );
     return;
   }
 
@@ -1113,26 +1220,25 @@
       var ypin = marker.toYahoo();
       marker.setChild(ypin);
       map.addOverlay(ypin);
-      if (! old) { this.markers.push(marker); }
+      if (!old) { this.markers.push(marker); }
       break;
     case 'google':
     case 'openstreetmap':
       var gpin = marker.toGoogle();
       marker.setChild(gpin);
       map.addOverlay(gpin);
-      if (! old) { this.markers.push(marker); }
+      if (!old) { this.markers.push(marker); }
       break;
     case 'microsoft':
       var mpin = marker.toMicrosoft();
       marker.setChild(mpin); // FIXME: MSFT maps remove the pin by pinID so this isn't needed?
       map.AddPushpin(mpin);
-      if (! old) { this.markers.push(marker); }
+      if (!old) { this.markers.push(marker); }
       break;
     case 'openlayers':
       //this.map.addPopup(new OpenLayers.Popup("chicken", new OpenLayers.LonLat(5,40), new OpenLayers.Size(200,200), "example popup"));
-      if (!this.layers['markers'])
-      {
-        this.layers['markers'] = new OpenLayers.Layer.Markers("markers");
+      if (!this.layers['markers']) {
+        this.layers['markers'] = new OpenLayers.Layer.Markers('markers');
         map.addLayer(this.layers['markers']);
       }
       var olmarker = marker.toOpenLayers();
@@ -1144,66 +1250,67 @@
       var mmpin = marker.toMultiMap();
       marker.setChild(mmpin);
       map.addOverlay(mmpin);
-      if (! old) { this.markers.push(marker); }
+      if (!old) { this.markers.push(marker); }
       break;
     case 'map24':
       var m24pin = marker.toMap24();
       marker.setChild(m24pin);
       m24pin.commit();
-      if (! old) { this.markers.push(marker); }
+      if (!old) { this.markers.push(marker); }
       break;
     case 'mapquest':
       var mqpin = marker.toMapQuest();
       marker.setChild(mqpin);
       map.addPoi(mqpin);
-      if (! old) { this.markers.push(marker); }
+      if (!old) { this.markers.push(marker); }
       break;
     case 'freeearth':
       var fepin = marker.toFreeEarth();
       marker.setChild(fepin);
       map.addOverlay(fepin);
-      if (! old) { this.markers.push(marker); }
+      if (!old) { this.markers.push(marker); }
       break;
-      default:
-      if(this.debug)
+    default:
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.addMarker');
+      }
   }
-}
+};
 
 /**
  * addMarkerWithData will addData to the marker, then add it to the map
- * @param{marker} marker The marker to add
- * @param{data} data A data has to add
+ * @param {Marker} marker The marker to add
+ * @param {Object} data A data has to add
  */
-Mapstraction.prototype.addMarkerWithData = function(marker,data) {
+Mapstraction.prototype.addMarkerWithData = function(marker, data) {
   marker.addData(data);
   this.addMarker(marker);
-}
+};
 
 /**
  * addPolylineWithData will addData to the polyline, then add it to the map
- * @param{polyline} polyline The polyline to add
- * @param{data} data A data has to add
+ * @param {Polyline} polyline The polyline to add
+ * @param {Object} data A data has to add
  */
-Mapstraction.prototype.addPolylineWithData = function(polyline,data) {
+Mapstraction.prototype.addPolylineWithData = function(polyline, data) {
   polyline.addData(data);
   this.addPolyline(polyline);
-}
+};
 
 /**
  * removeMarker removes a Marker from the map
  * @param {Marker} marker The marker to remove
  */
 Mapstraction.prototype.removeMarker = function(marker) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.removeMarker(marker); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.removeMarker(marker); } );
     return;
   }
 
   var map = this.maps[this.api];
 
-  var tmparray = new Array();
+  var tmparray = [];
   while(this.markers.length > 0){
     current_marker = this.markers.pop();
     if(marker == current_marker) {
@@ -1239,15 +1346,15 @@
     }
   }
   this.markers = this.markers.concat(tmparray);
-}
+};
 
 /**
  * removeAllMarkers removes all the Markers on a map
  */
 Mapstraction.prototype.removeAllMarkers = function() {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.removeAllMarkers(); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.removeAllMarkers(); } );
     return;
   }
 
@@ -1282,28 +1389,84 @@
       this.layers['markers'].clearMarkers();
       break;      
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.removeAllMarkers');
+      }
   }
 
-  this.markers = new Array(); // clear the mapstraction list of markers too
+  this.markers = []; // clear the mapstraction list of markers too
 
-}
+};
 
 
 /**
+ * Declutter the markers on the map, group together overlapping markers.
+ * @param {Object} opts Declutter options
+ */
+Mapstraction.prototype.declutterMarkers = function(opts) {
+	if(this.loaded[this.api] === false) {
+		self = this;
+		this.onload[this.api].push( function() { self.declutterMarkers(opts); } );
+		return;
+	}
+	
+	var map = this.maps[this.api];
+	
+	switch(this.api)
+	{
+//		case 'yahoo':
+//
+//			break;
+//		case 'google':
+//
+//			break;
+//		case 'openstreetmap':
+//
+//			break;
+//		case 'microsoft':
+//
+//			break;
+//		case 'openlayers':
+//
+//			break;
+		case 'multimap':
+			/*
+			 * Multimap supports quite a lot of decluttering options such as whether 
+			 * to use an accurate of fast declutter algorithm and what icon to use to 
+			 * represent a cluster. Using all this would mean abstracting all the enums
+			 * etc so we're only implementing the group name function at the moment.
+			 */
+			map.declutterGroup(opts.groupName);
+			break;
+//		case 'mapquest':
+//
+//			break;
+//		case 'map24':
+//
+//			break;			
+		default:
+			if(this.debug) {
+				alert(this.api + ' not supported by Mapstraction.declutterMarkers');
+			}
+	}
+};
+
+/**
  * Add a polyline to the map
+ * @param {Polyline} polyline The Polyline to add to the map
+ * @param {Boolean} old If true replaces an existing Polyline
  */
-Mapstraction.prototype.addPolyline = function(polyline,old) {
+Mapstraction.prototype.addPolyline = function(polyline, old) {
 
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.addPolyline(polyline,old); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.addPolyline(polyline, old); } );
     return;
   }
 
   var map = this.maps[this.api];
-
+  polyline.api = this.api;
+  polyline.map = this.maps[this.api];
   switch (this.api) {
     case 'yahoo':
       ypolyline = polyline.toYahoo();
@@ -1325,8 +1488,9 @@
       if(!old) {this.polylines.push(polyline);}
       break;
     case 'openlayers':
-      if(this.debug)
-        alert(this.api + ' not supported by Mapstraction.addPolyline');
+      if(this.debug) {
+	  	alert(this.api + ' not supported by Mapstraction.addPolyline');
+	  }
       break;
     case 'multimap':
       mmpolyline = polyline.toMultiMap();
@@ -1345,26 +1509,28 @@
       polyline.setChild(m24polyline);
       m24polyline.commit();
       if(!old) {this.polylines.push(polyline);}
-      break;            
+      break;			
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.addPolyline');
+      }
   }
-}
+};
 
 /**
  * Remove the polyline from the map
- */ 
+ * @param {Polyline} polyline The Polyline to remove from the map
+ */
 Mapstraction.prototype.removePolyline = function(polyline) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.removePolyline(polyline); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.removePolyline(polyline); } );
     return;
   }
-
+	
   var map = this.maps[this.api];
-
-  var tmparray = new Array();
+	
+  var tmparray = [];
   while(this.polylines.length > 0){
     current_polyline = this.polylines.pop();
     if(polyline == current_polyline) {
@@ -1396,29 +1562,29 @@
     }
   }
   this.polylines = this.polylines.concat(tmparray);
-}
-
+};
+	
 /**
  * Removes all polylines from the map
  */
 Mapstraction.prototype.removeAllPolylines = function() {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.removeAllPolylines(); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.removeAllPolylines(); } );
     return;
   }
 
   var map = this.maps[this.api];
-
+  
   switch (this.api) {
     case 'yahoo':
-      for(var i = 0, length = this.polylines.length;i < length;i++){
+      for(var i = 0, length = this.polylines.length; i < length; i++){
         map.removeOverlay(this.polylines[i].proprietary_polyline);
       }
       break;
     case 'google':
     case 'openstreetmap':
-      for(var i = 0, length = this.polylines.length;i < length;i++){
+      for(var i = 0, length = this.polylines.length; i < length; i++){
         map.removeOverlay(this.polylines[i].proprietary_polyline);
       }
       break;
@@ -1426,7 +1592,7 @@
       map.DeleteAllPolylines();
       break;
     case 'multimap':
-      for(var i = 0, length = this.polylines.length;i < length;i++){
+      for(var i = 0, length = this.polylines.length; i < length; i++){
         this.polylines[i].proprietary_polyline.remove();
       }
       break;
@@ -1442,73 +1608,72 @@
       }
       break;
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.removeAllPolylines');
-
+      }
   }
-  this.polylines = new Array(); 
-}
+  this.polylines = []; 
+};
 
 /**
  * getCenter gets the central point of the map
- * @returns  the center point of the map
- * @type LatLonPoint
+ * @type {LatLonPoint} The center point of the map
  */
 Mapstraction.prototype.getCenter = function() {
-  if(this.loaded[this.api] == false) {
+  if(this.loaded[this.api] === false) {
     return null;
   }
 
   var map = this.maps[this.api];
 
   var point = undefined;
+  var pt;
   switch (this.api) {
     case 'yahoo':
-      var pt = map.getCenterLatLon();
+      pt = map.getCenterLatLon();
       point = new LatLonPoint(pt.Lat,pt.Lon);
       break;
     case 'google':
     case 'openstreetmap':
-      var pt = map.getCenter();
+      pt = map.getCenter();
       point = new LatLonPoint(pt.lat(),pt.lng());
       break;
     case 'openlayers':
-      var pt = map.getCenter();
+      pt = map.getCenter();
       point = new LatLonPoint(pt.lat, pt.lon);
       break;
     case 'microsoft':
-      var pt = map.GetCenter();
+      pt = map.GetCenter();
       point = new LatLonPoint(pt.Latitude,pt.Longitude);
       break;
     case 'multimap':
-      var pt = map.getCurrentPosition();
-      point = new LatLonPoint(pt.y, pt.x);
+      pt = map.getMapBounds().getCenter();
+      point = new LatLonPoint(pt.lat, pt.lon);
       break;
     case 'mapquest':
-      var pt = map.getCenter();
+      pt = map.getCenter();
       point = new LatLonPoint(pt.getLatitude(), pt.getLongitude());
       break;
     case 'map24':
-      var pt = map.MapClient['Static'].getCurrentMapView().getCenter();
+      pt = map.MapClient['Static'].getCurrentMapView().getCenter();
       point = new LatLonPoint(pt.Y/60,pt.X/60);
       break;
-
-
     default:
-      if(this.debug)
-        alert(this.api + ' not supported by Mapstraction.getCenter');
+      if(this.debug) {
+        alert(this.api + ' not supported by Mapstraction.getCenter');			
+      }
   }
   return point;
-}
+};
 
 /**
  * setCenter sets the central point of the map
  * @param {LatLonPoint} point The point at which to center the map
  */
 Mapstraction.prototype.setCenter = function(point) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.setCenter(point); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.setCenter(point); } );
     return;
   }
 
@@ -1536,11 +1701,11 @@
       break;
     case 'freeearth':
       if (this.freeEarthLoaded) {
-      map.setTargetLatLng( point.toFreeEarth() );
-      } else {
-        myself = this;
-        this.freeEarthOnLoad.push( function() { myself.setCenterAndZoom(point); }
-            );
+      	map.setTargetLatLng( point.toFreeEarth() );
+      } 
+      else {
+        self = this;
+        this.freeEarthOnLoad.push( function(){ self.setCenterAndZoom(point); } );
       }
       break;
     case 'map24':
@@ -1548,7 +1713,7 @@
       // we have to get the original metre width and pass it back in when
       // centering.
       var mv = map.MapClient['Static'].getCurrentMapView();
-      var newSettings = new Object();
+      var newSettings = {};
       newSettings.MinimumWidth = lonToMetres 
         (mv.LowerRight.Longitude - mv.TopLeft.Longitude,
          (mv.LowerRight.Latitude+mv.TopLeft.Latitude)/2);
@@ -1557,10 +1722,13 @@
       Map24.MapApplication.center(newSettings);
       break;
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.setCenter');
+      }
   }
-}
+};
+
+
 /**
  * setZoom sets the zoom level for the map
  * MS doesn't seem to do zoom=0, and Gg's sat goes closer than it's maps, and MS's sat goes closer than Y!'s
@@ -1568,9 +1736,9 @@
  * @param {int} zoom The (native to the map) level zoom the map to.
  */
 Mapstraction.prototype.setZoom = function(zoom) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.setZoom(zoom); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.setZoom(zoom); } );
     return;
   }
 
@@ -1596,11 +1764,11 @@
       break;
     case 'mapquest':
       map.setZoomLevel(zoom - 3); // MapQuest seems off by 3
-      break;            
+      break;			
     case 'map24':
       // get the current centre than calculate the settings based on this
       var point = this.getCenter();
-      var newSettings = new Object();
+      var newSettings = {};
       newSettings.Latitude = point.lat*60;
       newSettings.Longitude = point.lon*60;
       var client = map.MapClient['Static'];
@@ -1610,19 +1778,20 @@
       Map24.MapApplication.center ( newSettings );
       break;
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.setZoom');
+      }
   }
-}
+};
+
 /**
  * autoCenterAndZoom sets the center and zoom of the map to the smallest bounding box
- *  containing all markers
- *
+ * containing all markers
  */
 Mapstraction.prototype.autoCenterAndZoom = function() {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.autoCenterAndZoom(); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.autoCenterAndZoom(); } );
     return;
   }
 
@@ -1631,27 +1800,42 @@
   var lon_max = -180;
   var lon_min = 180;
 
-  for (var i=0; i<this.markers.length; i++) {;
+  for (var i=0; i<this.markers.length; i++) {
     lat = this.markers[i].location.lat;
     lon = this.markers[i].location.lon;
-    if (lat > lat_max) lat_max = lat;
-    if (lat < lat_min) lat_min = lat;
-    if (lon > lon_max) lon_max = lon;
-    if (lon < lon_min) lon_min = lon;
+    if (lat > lat_max) {
+      lat_max = lat;
+    }
+    if (lat < lat_min) {
+      lat_min = lat;
+    }
+    if (lon > lon_max) {
+      lon_max = lon;
+    }
+    if (lon < lon_min) {
+      lon_min = lon;
+    }
   }
-  for (i=0; i<this.polylines.length; i++) {
-    for (j=0; j<this.polylines[i].points.length; j++) {
+  for (var i=0; i<this.polylines.length; i++) {
+    for (var j=0; j<this.polylines[i].points.length; j++) {
       lat = this.polylines[i].points[j].lat;
       lon = this.polylines[i].points[j].lon;
-
-      if (lat > lat_max) lat_max = lat;
-      if (lat < lat_min) lat_min = lat;
-      if (lon > lon_max) lon_max = lon;
-      if (lon < lon_min) lon_min = lon;      
+      if (lat > lat_max) {
+        lat_max = lat;
+      }
+      if (lat < lat_min) {
+        lat_min = lat;
+      }
+      if (lon > lon_max) {
+        lon_max = lon;
+      }
+      if (lon < lon_min) {
+        lon_min = lon;
+      }      
     }
   }
   this.setBounds( new BoundingBox(lat_min, lon_min, lat_max, lon_max) );
-}
+};
 
 /** 
  * centerAndZoomOnPoints sets the center and zoom of the map from an array of points
@@ -1659,23 +1843,22 @@
  * This is useful if you don't want to have to add markers to the map
  */
 Mapstraction.prototype.centerAndZoomOnPoints = function(points) {
-    var bounds = new BoundingBox(points[0].lat,points[0].lon,points[0].lat,points[0].lon);
-    
-    for (var i=1, len = points.length ; i<len; i++) {
-        bounds.extend(points[i]);
-    }
+	var bounds = new BoundingBox(points[0].lat,points[0].lon,points[0].lat,points[0].lon);
+	
+	for (var i=1, len = points.length ; i<len; i++) {
+		bounds.extend(points[i]);
+	}
      
-    this.setBounds(bounds);
-} 
+	this.setBounds(bounds);
+};
 
 /**
  * getZoom returns the zoom level of the map
- * @returns the zoom level of the map
- * @type int
+ * @type {Integer} The zoom level of the map
  */
 Mapstraction.prototype.getZoom = function() {
-  if(this.loaded[this.api] == false) {
-    myself = this;
+  if(this.loaded[this.api] === false) {
+    self = this;
     return -1;
   }
 
@@ -1694,7 +1877,7 @@
     case 'multimap':
       return map.getZoomFactor();
     case 'mapquest':
-      return map.getZoomLevel() + 3; // Mapquest seems off by 3?            
+      return map.getZoomLevel() + 3; // Mapquest seems off by 3?			
     case 'map24': 
       // since map24 doesn't use a Google-style set of zoom levels, we have
       // to round to the nearest zoom
@@ -1704,59 +1887,59 @@
       var zoom = getGoogleZoomLevelFromDegrees (width,dLon);
       return Math.round(zoom);
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.getZoom');
+      }
   }
-}
+};
 
 /**
  * getZoomLevelForBoundingBox returns the best zoom level for bounds given
  * @param boundingBox the bounds to fit
- * @returns the closest zoom level that contains the bounding box
- * @type int
+ * @type {Integer} The closest zoom level that contains the bounding box
  */
 Mapstraction.prototype.getZoomLevelForBoundingBox = function( bbox ) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
+  if(this.loaded[this.api] === false) {
+    self = this;
     return -1;
   }
-
+	
   var map = this.maps[this.api];
-
+	
   // NE and SW points from the bounding box.
   var ne = bbox.getNorthEast();
   var sw = bbox.getSouthWest();
-
+  var zoom;
+	
   switch (this.api) {
     case 'google':
+      // no break statement here intentionally
     case 'openstreetmap':
       var gbox = new GLatLngBounds( sw.toGoogle(), ne.toGoogle() );
-      var zoom = map.getBoundsZoomLevel( gbox );
+      zoom = map.getBoundsZoomLevel( gbox );
       return zoom;
-      break;
     case 'openlayers':
       var olbox = bbox.toOpenLayers();
-      var zoom = map.getZoomForExtent(olbox);
-      break;
+      zoom = map.getZoomForExtent(olbox);
+	  return zoom;
     case 'multimap':
-      var mmlocation = map.getBoundsZoomFactor( sw.toMultiMap(), ne.toMultiMap() );
-      var zoom = mmlocation.zoom_factor();
+      var mmlocation = map.getAutoScaleLocation( [sw.toMultiMap(), ne.toMultiMap()] );
+      zoom = mmlocation.zoom_factor;
       return zoom;
-      break;
     case 'map24':
       // since map24 doesn't use a Google-style set of zoom levels, we work
       // out what zoom level will show the given longitude difference within
       // the current map pixel width
       var dLon = ne.lon - sw.lon; 
       var width = map.MapClient['Static'].getCanvasSize().Width;
-      var zoom = getGoogleZoomLevelFromDegrees (width,dLon);
+      zoom = getGoogleZoomLevelFromDegrees (width,dLon);
       return Math.round(zoom);
-      break;
     default:
-      if(this.debug)
+      if(this.debug) {
         alert( this.api + ' not supported by Mapstraction.getZoomLevelForBoundingBox' );
+      }
   }
-}
+};
 
 
 // any use this being a bitmask? Should HYBRID = ROAD | SATELLITE?
@@ -1764,6 +1947,9 @@
 Mapstraction.SATELLITE = 2;
 Mapstraction.HYBRID = 3;
 
+
+
+
 /**
  * setMapType sets the imagery type for the map.
  * The type can be one of:
@@ -1773,9 +1959,9 @@
  * @param {int} type The (native to the map) level zoom the map to.
  */
 Mapstraction.prototype.setMapType = function(type) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.setMapType(type); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.setMapType(type); } );
     return;
   }
 
@@ -1869,11 +2055,13 @@
       }
       break;
     default:
-      if(this.debug)
+      if(this.debug){
         alert(this.api + ' not supported by Mapstraction.setMapType');
+      }
   }
-}
+};
 
+
 /**
  * getMapType gets the imagery type for the map.
  * The type can be one of:
@@ -1882,8 +2070,8 @@
  * Mapstraction.HYBRID
  */
 Mapstraction.prototype.getMapType = function() {
-  if(this.loaded[this.api] == false) {
-    myself = this;
+  if(this.loaded[this.api] === false) {
+    self = this;
     return -1;
   }
 
@@ -1896,13 +2084,10 @@
       switch(type) {
         case YAHOO_MAP_REG:
           return Mapstraction.ROAD;
-          break;
         case YAHOO_MAP_SAT:
           return Mapstraction.SATELLITE;
-          break;
         case YAHOO_MAP_HYB:
           return Mapstraction.HYBRID;
-          break;
         default:
           return null;
       }
@@ -1913,13 +2098,10 @@
       switch(type) {
         case G_NORMAL_MAP:
           return Mapstraction.ROAD;
-          break;
         case G_SATELLITE_MAP:
           return Mapstraction.SATELLITE;
-          break;
         case G_HYBRID_MAP:
           return Mapstraction.HYBRID;
-          break;
         default:
           return null;
       }
@@ -1930,13 +2112,10 @@
       switch(type) {
         case Msn.VE.MapStyle.Road:
           return Mapstraction.ROAD;
-          break;
         case Msn.VE.MapStyle.Aerial:
           return Mapstraction.SATELLITE;
-          break;
         case Msn.VE.MapStyle.Hybrid:
           return Mapstraction.HYBRID;
-          break;
         default:
           return null;
       }
@@ -1947,13 +2126,10 @@
       switch(type) {
         case MM_WORLD_MAP:
           return Mapstraction.ROAD;
-          break;
         case MM_WORLD_AERIAL:
           return Mapstraction.SATELLITE;
-          break;
         case MM_WORLD_HYBRID:
           return Mapstraction.HYBRID;
-          break;
         default:
           return null;
       }
@@ -1963,22 +2139,20 @@
       switch(type) {
         case "map":
           return Mapstraction.ROAD;
-        break;
         case "sat":
           return Mapstraction.SATELLITE;
-        break;
         case "hyb":
           return Mapstraction.HYBRID;
-        break;
         default:
-        return null;
+          return null;
       }
-      break;            
+      break;			
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.getMapType');
+      }
   } 
-}
+};
 
 /**
  * getBounds gets the BoundingBox of the map
@@ -1986,73 +2160,66 @@
  * @type BoundingBox
  */
 Mapstraction.prototype.getBounds = function () {
-  if(this.loaded[this.api] == false) {
+  if(this.loaded[this.api] === false) {
     return null; 
   }
 
   var map = this.maps[this.api];
-
+  var ne, sw, nw, se;
   switch (this.api) {
     case 'google':
     case 'openstreetmap':
       var gbox = map.getBounds();
-      var sw = gbox.getSouthWest();
-      var ne = gbox.getNorthEast();
+      sw = gbox.getSouthWest();
+      ne = gbox.getNorthEast();
       return new BoundingBox(sw.lat(), sw.lng(), ne.lat(), ne.lng());
-      break;
     case 'openlayers':
       var olbox = map.calculateBounds();
-      break;
+      return new BoundingBox(olbox.bottom, olbox.left, olbox.top, olbox.right);
     case 'yahoo':
       var ybox = map.getBoundsLatLon();
       return new BoundingBox(ybox.LatMin, ybox.LonMin, ybox.LatMax, ybox.LonMax);
-      break;
     case 'microsoft':
       var mbox = map.GetMapView();
-      var nw = mbox.TopLeftLatLong;
-      var se = mbox.BottomRightLatLong;
+      nw = mbox.TopLeftLatLong;
+      se = mbox.BottomRightLatLong;
       return new BoundingBox(se.Latitude,nw.Longitude,nw.Latitude,se.Longitude);
-      break;
     case 'multimap':
       var mmbox = map.getMapBounds();
-      var sw = mmbox.getSouthWest();
-      var ne = mmbox.getNorthEast();
+      sw = mmbox.getSouthWest();
+      ne = mmbox.getNorthEast();
       return new BoundingBox(sw.lat, sw.lon, ne.lat, ne.lon);
-      break;
     case 'mapquest':
       var mqbox = map.getMapBounds(); // MQRectLL
-      var se = mqbox.getLowerRightLatLng();
-      var nw = mqbox.getUpperLeftLatLng();
+      se = mqbox.getLowerRightLatLng();
+      nw = mqbox.getUpperLeftLatLng();
 
       // NW is this correct ???
       // return new BoundingBox(se.lat, se.lon, nw.lat, nw.lon);
 
       // should be this instead 
-      return new BoundingBox(se.lat, nw.lon, nw.lat, se.lon);
-
-      break;            
+      return new BoundingBox(se.lat, nw.lon, nw.lat, se.lon);            
     case 'map24':
       var mv = map.MapClient['Static'].getCurrentMapView();
-      var se = mv.LowerRight;
-      var nw = mv.TopLeft;
+      se = mv.LowerRight;
+      nw = mv.TopLeft;
       return new BoundingBox (se.Latitude/60, nw.Longitude/60, 
-          nw.Latitude/60, se.Longitude/60 );
-      break;            
+          nw.Latitude/60, se.Longitude/60 );			
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.getBounds');
-
+      }
   }
-}
+};
 
 /**
  * setBounds sets the map to the appropriate location and zoom for a given BoundingBox
  * @param {BoundingBox} the bounding box you want the map to show
  */
 Mapstraction.prototype.setBounds = function(bounds){
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.setBounds(bounds); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.setBounds(bounds); } );
     return;
   }
 
@@ -2068,14 +2235,15 @@
       break;
 
     case 'openlayers':
-      var bounds = new OpenLayers.Bounds();
-      bounds.extend(new LatLonPoint(sw.lat,sw.lon).toOpenLayers());
-      bounds.extend(new LatLonPoint(ne.lat,ne.lon).toOpenLayers());
-      map.zoomToExtent(bounds);
+      var obounds = new OpenLayers.Bounds();
+      obounds.extend(new LatLonPoint(sw.lat,sw.lon).toOpenLayers());
+      obounds.extend(new LatLonPoint(ne.lat,ne.lon).toOpenLayers());
+      map.zoomToExtent(obounds);
       break;
     case 'yahoo':
-      if(sw.lon > ne.lon)
+      if(sw.lon > ne.lon) {
         sw.lon -= 360;
+      }
       var center = new YGeoPoint((sw.lat + ne.lat)/2,
           (ne.lon + sw.lon)/2);
 
@@ -2083,11 +2251,12 @@
       for(var zoom = 1 ; zoom <= 17 ; zoom++){
         var sw_pix = convertLatLonXY_Yahoo(sw,zoom);
         var ne_pix = convertLatLonXY_Yahoo(ne,zoom);
-        if(sw_pix.x > ne_pix.x)
+        if(sw_pix.x > ne_pix.x) {
           sw_pix.x -= (1 << (26 - zoom)); //earth circumference in pixel
-        if(Math.abs(ne_pix.x - sw_pix.x)<=container.width
+        }
+        if(Math.abs(ne_pix.x - sw_pix.x) <= container.width
             && Math.abs(ne_pix.y - sw_pix.y) <= container.height){
-          map.drawZoomAndCenter(center,zoom); //Call drawZoomAndCenter here: OK if called multiple times anyway
+          map.drawZoomAndCenter(center, zoom); //Call drawZoomAndCenter here: OK if called multiple times anyway
           break;
         }
       }
@@ -2096,23 +2265,21 @@
       map.SetMapView([new VELatLong(sw.lat,sw.lon),new VELatLong(ne.lat,ne.lon)]);
       break;
     case 'multimap':
-      var mmlocation = map.getBoundsZoomFactor( sw.toMultiMap(), ne.toMultiMap() );
-      var center = new LatLonPoint(mmlocation.coords.lat, mmlocation.coords.lon);
-      this.setCenterAndZoom(center, mmlocation.zoom_factor);
+      var mmlocation = map.getAutoScaleLocation([sw.toMultiMap(), ne.toMultiMap()]);
+      map.goToPosition(mmlocation.coords, mmlocation.zoom_factor);
       break;
     case 'mapquest':
       // TODO: MapQuest.setBounds
-      if(this.debug)
-        alert(this.api + ' not supported by Mapstraction.setBounds');            
-
-      break;            
+      if(this.debug) {
+        alert(this.api + ' not supported by Mapstraction.setBounds');
+      }
+      break;			
     case 'freeearth':
       var center = new LatLonPoint((sw.lat + ne.lat)/2, (ne.lon + sw.lon)/2);
-      this.setCenter(center);    
+      this.setCenter(center);	
       break;
-
     case 'map24':
-      var settings = new Object();
+      var settings = {};
       settings.Latitude = ((sw.lat+ne.lat) / 2) * 60;    
       settings.Longitude = ((sw.lon+ne.lon) / 2) * 60;    
 
@@ -2120,14 +2287,15 @@
       settings.MinimumWidth = lonToMetres 
         (ne.lon-sw.lon, (ne.lat+sw.lat)/2);
 
-      Map24.MapApplication.center ( settings );
+      Map24.MapApplication.center(settings);
 
       break;
     default:
-      if(this.debug)
-        alert(this.api + ' not supported by Mapstraction.setBounds');            
+      if(this.debug) {
+        alert(this.api + ' not supported by Mapstraction.setBounds');
+      }
   }
-}
+};
 
 /**
  * addImageOverlay layers an georeferenced image over the map
@@ -2140,9 +2308,9 @@
  * @param {north} north boundary
  */
 Mapstraction.prototype.addImageOverlay = function(id, src, opacity, west, south, east, north) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.addImageOverlay(id, src, opacity, west, south, east, north); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.addImageOverlay(id, src, opacity, west, south, east, north); } );
     return;
   }
 
@@ -2165,8 +2333,8 @@
       map.getPane(G_MAP_MAP_PANE).appendChild(b);
       this.setImageOpacity(id, opacity);
       this.setImagePosition(id);
-      GEvent.bind(map, "zoomend", this, function(){this.setImagePosition(id)});
-      GEvent.bind(map, "moveend", this, function(){this.setImagePosition(id)});
+      GEvent.bind(map, "zoomend", this, function() { this.setImagePosition(id); });
+      GEvent.bind(map, "moveend", this, function() { this.setImagePosition(id); });
       break;
 
     case 'multimap':
@@ -2187,51 +2355,53 @@
 
     default:
       b.style.display = 'none';
-      if(this.debug)
+      if (this.debug) {
         alert(this.api + "not supported by Mapstraction.addImageOverlay not supported");
+      }
       break;
   }
-}     
+};
 
 Mapstraction.prototype.setImageOpacity = function(id, opacity) {
-  if(opacity<0){opacity=0;}  if(opacity>=100){opacity=100;}
-  var c=opacity/100;
-  var d=document.getElementById(id);
-  if(typeof(d.style.filter)=='string'){d.style.filter='alpha(opacity:'+opacity+')';}
-      if(typeof(d.style.KHTMLOpacity)=='string'){d.style.KHTMLOpacity=c;}
-      if(typeof(d.style.MozOpacity)=='string'){d.style.MozOpacity=c;}
-      if(typeof(d.style.opacity)=='string'){d.style.opacity=c;} 
-      }
+  if (opacity < 0) { opacity = 0; }  
+  if (opacity >= 100) { opacity = 100; }
+  var c = opacity / 100;
+  var d = document.getElementById(id);
+  if(typeof(d.style.filter)=='string'){ d.style.filter='alpha(opacity:'+opacity+')'; }
+  if(typeof(d.style.KHTMLOpacity)=='string'){ d.style.KHTMLOpacity=c; }
+  if(typeof(d.style.MozOpacity)=='string'){ d.style.MozOpacity=c; }
+  if(typeof(d.style.opacity)=='string'){ d.style.opacity=c; } 
+};
 
-      Mapstraction.prototype.setImagePosition = function(id) {
-      if(this.loaded[this.api] == false) {
-      myself = this;
-      this.onload[this.api].push( function() { myself.setImagePosition(id); } );
-      return;
-      }
+Mapstraction.prototype.setImagePosition = function(id) {
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.setImagePosition(id); } );
+    return;
+  }
 
-      var map = this.maps[this.api];
-      var x = document.getElementById(id);
-      var d; var e;
+  var map = this.maps[this.api];
+  var x = document.getElementById(id);
+  var d; var e;
+	
+  switch (this.api) {
+    case 'google':
+    case 'openstreetmap':
+      d = map.fromLatLngToDivPixel(new GLatLng(x.getAttribute('north'), x.getAttribute('west')));
+      e = map.fromLatLngToDivPixel(new GLatLng(x.getAttribute('south'), x.getAttribute('east')));
+      break;
+    case 'multimap':
+      d = map.geoPosToContainerPixels(new MMLatLon(x.getAttribute('north'), x.getAttribute('west')));
+      e = map.geoPosToContainerPixels(new MMLatLon(x.getAttribute('south'), x.getAttribute('east')));
+      break;
+  }
+	
+  x.style.top = d.y.toString() + 'px';
+  x.style.left = d.x.toString() + 'px';
+  x.style.width = (e.x - d.x).toString() + 'px';
+  x.style.height = (e.y - d.y).toString() + 'px'; 
+};
 
-      switch (this.api) {
-      case 'google':
-      case 'openstreetmap':
-        d = map.fromLatLngToDivPixel(new GLatLng(x.getAttribute('north'), x.getAttribute('west')));
-        e = map.fromLatLngToDivPixel(new GLatLng(x.getAttribute('south'), x.getAttribute('east')));
-        break;
-      case 'multimap':
-        d = map.geoPosToContainerPixels(new MMLatLon(x.getAttribute('north'), x.getAttribute('west')));
-        e = map.geoPosToContainerPixels(new MMLatLon(x.getAttribute('south'), x.getAttribute('east')));
-        break;
-      }
-
-      x.style.top=d.y+'px';
-      x.style.left=d.x+'px';
-      x.style.width=e.x-d.x+'px';
-      x.style.height=e.y-d.y+'px'; 
-      }
-
 /**
  * addOverlay adds a GeoRSS or KML overlay to the map
  *  some flavors of GeoRSS and KML are not supported by some of the Map providers
@@ -2239,9 +2409,9 @@
  * @param{autoCenterAndZoom} set true to auto center and zoom after the feed is loaded
  */
 Mapstraction.prototype.addOverlay = function(url, autoCenterAndZoom) {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.addOverlay(url); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.addGeoRSSOverlay(georssURL); } );
     return;
   }
 
@@ -2274,21 +2444,24 @@
       break;
     case 'freeearth':
       if (this.freeEarthLoaded) {
-      var ferss = new FE.GeoRSS(url);
-      map.addOverlay(ferss);
-      } else {
-        myself = this;
-        this.freeEarthOnLoad.push( function() { myself.addOverlay(url); } );
+        var ferss = new FE.GeoRSS(url);
+        map.addOverlay(ferss);
+      } 
+      else {
+        self = this;
+        this.freeEarthOnLoad.push( function() { self.addGeoRSSOverlay(url); } );
       }
       break;
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(this.api + ' not supported by Mapstraction.addGeoRSSOverlay');
+      }
   }
 
-}
+};
 
-/* Adds a Tile Layer to the map
+/**
+ * Adds a Tile Layer to the map
  * 
  * Requires providing a parameterized tile url. Use {Z}, {X}, and {Y} to specify where the parameters 
  *  should go in the URL. 
@@ -2303,71 +2476,77 @@
  * @param {max_zoom} Maximum (closest) zoom level that the tiles are available (default=18)
  */
 Mapstraction.prototype.addTileLayer = function(tile_url, opacity, copyright_text, min_zoom, max_zoom) {
-    if(!tile_url)
-        return;
-	if (! this.tileLayers) {
-		this.tileLayers = [];
-	}    
-	if(!opacity)
-	    opacity = 0.6;
-	if(!copyright_text)
-	    copyright_text = "Mapstraction";
-	if(!min_zoom)
-	    min_zoom = 1;
-	if(!max_zoom)
-	    max_zoom = 18;
-	    
-    console.log(this.api);
-    switch (this.api) {
-        case 'google':
-        case 'openstreetmap':
-        var copyright = new GCopyright(1, new GLatLngBounds(new GLatLng(-90,-180), new GLatLng(90,180)), 0, "copyleft"); 
-        var copyrightCollection = new GCopyrightCollection(copyright_text); 
-        copyrightCollection.addCopyright(copyright); 
+  if(!tile_url) {
+    return;
+  }
+  if(!this.tileLayers) {
+    this.tileLayers = [];
+  }    
+  if(!opacity) {
+    opacity = 0.6;
+  }  
+  if(!copyright_text) {
+    copyright_text = "Mapstraction";
+  }
+  if(!min_zoom) {
+    min_zoom = 1;
+  }
+  if(!max_zoom) {
+    max_zoom = 18;
+  }
+    
+  console.log(this.api);
+  switch (this.api) {
+    case 'google':
+    case 'openstreetmap':
+      var copyright = new GCopyright(1, new GLatLngBounds(new GLatLng(-90,-180), new GLatLng(90,180)), 0, "copyleft"); 
+      var copyrightCollection = new GCopyrightCollection(copyright_text); 
+      copyrightCollection.addCopyright(copyright); 
+  
+      var tilelayers = []; 
+      tilelayers[0] = new GTileLayer(copyrightCollection, min_zoom, max_zoom); 
+      tilelayers[0].isPng = function() { return true; };
+      tilelayers[0].getOpacity = function() { return opacity; };   
+      tilelayers[0].getTileUrl = function (a, b) {
+        url = tile_url;
+        url = url.replace(/\{Z\}/,b);
+        url = url.replace(/\{X\}/,a.x);
+        url = url.replace(/\{Y\}/,a.y);
+        return url;
+      };
+      tileLayerOverlay = new GTileLayerOverlay(tilelayers[0]);
+  
+      this.tileLayers.push( [tile_url, tileLayerOverlay, true] );
+      this.maps[this.api].addOverlay(tileLayerOverlay);
+      break;
 
-        var tilelayers = new Array(); 
-        tilelayers[0] = new GTileLayer(copyrightCollection, min_zoom, max_zoom); 
-        tilelayers[0].isPng = function() { return true;};
-        tilelayers[0].getOpacity = function() { return opacity; }            
-        tilelayers[0].getTileUrl = function (a, b) {
-            url = tile_url;
-            url = url.replace(/\{Z\}/,b);
-            url = url.replace(/\{X\}/,a.x);
-            url = url.replace(/\{Y\}/,a.y);
-            return url             
-        };
-        tileLayerOverlay = new GTileLayerOverlay(tilelayers[0]);
+  }
+  return tileLayerOverlay;
+};
 
-        this.tileLayers.push( [tile_url, tileLayerOverlay, true] );
-        this.maps[this.api].addOverlay(tileLayerOverlay);
-        break;
-
-    }
-    return tileLayerOverlay;
-}
-
-/* Turns a Tile Layer on or off
- * 
+/**
+ * Turns a Tile Layer on or off
  * @param {tile_url} url of the tile layer that was created. 
  */
 Mapstraction.prototype.toggleTileLayer = function(tile_url) {
-    switch (this.api) {
-        case 'google':
-        case 'openstreetmap':
-        for (var f=0; f<this.tileLayers.length; f++) {
-            if(this.tileLayers[f][0] == tile_url) {
-                if(this.tileLayers[f][2]) {
-                    this.maps[this.api].removeOverlay(this.tileLayers[f][1]);
-                    this.tileLayers[f][2] = false;
-                } else {
-                    this.maps[this.api].addOverlay(this.tileLayers[f][1]);
-                    this.tileLayers[f][2] = true;                    
-                }
-            }
-        }        
-        break;
-    }
-}
+  switch (this.api) {
+    case 'google':
+    case 'openstreetmap':
+      for (var f=0; f<this.tileLayers.length; f++) {
+        if(this.tileLayers[f][0] == tile_url) {
+          if(this.tileLayers[f][2]) {
+              this.maps[this.api].removeOverlay(this.tileLayers[f][1]);
+              this.tileLayers[f][2] = false;
+          } 
+          else {
+              this.maps[this.api].addOverlay(this.tileLayers[f][1]);
+              this.tileLayers[f][2] = true;                    
+          }
+        }
+      }        
+      break;
+  }
+};
 
 /**
  * addFilter adds a marker filter
@@ -2376,17 +2555,20 @@
  * @param {value} the value to compare against
  */
 Mapstraction.prototype.addFilter = function(field, operator, value) {
-  if (! this.filters) {
+  if (!this.filters) {
     this.filters = [];
   }
   this.filters.push( [field, operator, value] );
-}
+};
 
 /**
- * removeFilter
+ * Remove the specified filter
+ * @param {Object} field
+ * @param {Object} operator
+ * @param {Object} value
  */
 Mapstraction.prototype.removeFilter = function(field, operator, value) {
-  if (! this.filters) { return; }
+  if (!this.filters) { return; }
 
   var del;
   for (var f=0; f<this.filters.length; f++) {
@@ -2396,18 +2578,21 @@
       f--; //array size decreased
     }
   }
-}
+};
 
-/*
- * toggleFilter: delete the current filter if present; otherwise add it
+/**
+ * Delete the current filter if present; otherwise add it
+ * @param {Object} field
+ * @param {Object} operator
+ * @param {Object} value
  */
 Mapstraction.prototype.toggleFilter = function(field, operator, value) {
-  if (! this.filters) { 
+  if (!this.filters) { 
     this.filters = [];
   }
 
   var found = false;
-  for (var f=0; f<this.filters.length; f++) {
+  for (var f = 0; f < this.filters.length; f++) {
     if (this.filters[f][0] == field && this.filters[f][1] == operator && this.filters[f][2] == value) {
       this.filters.splice(f,1);
       f--; //array size decreased
@@ -2418,22 +2603,22 @@
   if (! found) {
     this.addFilter(field, operator, value);
   }
-}
+};
 
-/*
+/**
  * removeAllFilters
  */
 Mapstraction.prototype.removeAllFilters = function() {
   this.filters = [];
-}
+};
 
 /**
  * doFilter executes all filters added since last call
  */
 Mapstraction.prototype.doFilter = function() {
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.doFilter(); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.doFilter(); } );
     return;
   }
 
@@ -2448,14 +2633,14 @@
         for (var f=0; f<this.filters.length; f++) {
           mmfilters.push( new MMSearchFilter( this.filters[f][0], this.filters[f][1], this.filters[f][2] ));
         }
-        map.setMarkerFilters( mmfilters );    
-        map.redrawMap();            
+        map.setMarkerFilters( mmfilters );	
+        map.redrawMap();			
         break;
       default:
-        var vis;    
+        var vis;	
         for (var m=0; m<this.markers.length; m++) {
           vis = true;
-          for (var f=0; f<this.filters.length; f++) {
+          for (var f = 0; f < this.filters.length; f++) {
             if (! this.applyFilter(this.markers[m], this.filters[f])) {
               vis = false;
             }
@@ -2488,7 +2673,7 @@
 
   }
 
-}
+};
 
 Mapstraction.prototype.applyFilter = function(o, f) {
   var vis = true;
@@ -2511,7 +2696,7 @@
   }
 
   return vis;
-}
+};
 
 /**
  * getAttributeExtremes returns the minimum/maximum of "field" from all markers
@@ -2539,8 +2724,10 @@
   }
 
   return [min, max];
-}
+};
 
+
+
 /**
  * getMap returns the native map object that mapstraction is talking to
  * @returns the native map object mapstraction is using
@@ -2548,7 +2735,7 @@
 Mapstraction.prototype.getMap = function() {
   // FIXME in an ideal world this shouldn't exist right?
   return this.maps[this.api];
-}
+};
 
 
 //////////////////////////////
@@ -2564,7 +2751,7 @@
  * @returns a new LatLonPoint
  * @type LatLonPoint
  */
-function LatLonPoint(lat,lon) {
+function LatLonPoint(lat, lon) {
   // TODO error if undefined?
   //  if (lat == undefined) alert('undefined lat');
   //  if (lon == undefined) alert('undefined lon');
@@ -2579,14 +2766,17 @@
  */
 LatLonPoint.prototype.toYahoo = function() {
   return new YGeoPoint(this.lat,this.lon);
-}
+};
+
 /**
  * toGoogle returns a Google maps point
  * @returns a GLatLng
  */
 LatLonPoint.prototype.toGoogle = function() {
   return new GLatLng(this.lat,this.lon);
-}
+};
+
+
 /**
  * toOpenLayers returns an OpenLayers point
  * Does a conversion from Latitude/Longitude to projected coordinates
@@ -2598,7 +2788,7 @@
    ollat = ollat * 20037508.34 / 180;
    //console.log("COORD: " + this.lat + ', ' + this.lon + " OL: " + ollat + ', ' +ollon);
    return new OpenLayers.LonLat(ollon, ollat);
-}
+};
 
 /**
  * fromOpenLayers converts an OpenLayers point to Mapstraction LatLonPoint
@@ -2613,21 +2803,23 @@
 
    this.lon = lon;
    this.lat = lat;
-}
+};
+
 /**
  * toMicrosoft returns a VE maps point
  * @returns a VELatLong
  */
 LatLonPoint.prototype.toMicrosoft = function() {
   return new VELatLong(this.lat,this.lon);
-}
+};
+
 /**
  * toMultiMap returns a MultiMap point
  * @returns a MMLatLon
  */
 LatLonPoint.prototype.toMultiMap = function() {
   return new MMLatLon(this.lat, this.lon);
-}
+};
 
 /**
  * toMapQuest returns a MapQuest point
@@ -2635,7 +2827,7 @@
  */
 LatLonPoint.prototype.toMapQuest = function() {
   return new MQLatLng(this.lat, this.lon);
-}
+};
 
 /**
  * toFreeEarth returns a FreeEarth point
@@ -2643,7 +2835,7 @@
  */
 LatLonPoint.prototype.toFreeEarth = function() {
   return new FE.LatLng(this.lat,this.lon);
-}
+};
 
 /**
  * toMap24 returns a Map24 point
@@ -2651,7 +2843,7 @@
  */
 LatLonPoint.prototype.toMap24 = function() {
   return new Map24.Point (this.lon,this.lat);
-}
+};
 
 
 /**
@@ -2661,7 +2853,8 @@
  */
 LatLonPoint.prototype.toString = function() {
   return this.lat + ', ' + this.lon;
-}
+};
+
 /**
  * distance returns the distance in kilometers between two points
  * @param {LatLonPoint} otherPoint The other point to measure the distance from to this one
@@ -2669,14 +2862,13 @@
  * @type double
  */
 LatLonPoint.prototype.distance = function(otherPoint) {
-  var d,dr;
-  with (Math) {
-    dr = 0.017453292519943295; // 2.0 * PI / 360.0; or, radians per degree
-    d = cos(otherPoint.lon*dr - this.lon*dr) * cos(otherPoint.lat*dr - this.lat*dr);
-    return acos(d)*6378.137; // equatorial radius
-  }
-  return -1; 
-}
+	var d, dr;
+	dr = 0.017453292519943295; // 2.0 * PI / 360.0; or, radians per degree
+	d = Math.cos(otherPoint.lon*dr - this.lon*dr) * Math.cos(otherPoint.lat*dr - this.lat*dr);
+	return Math.acos(d)*6378.137; // equatorial radius
+	//return -1; 
+};
+
 /**
  * equals tests if this point is the same as some other one
  * @param {LatLonPoint} otherPoint The other point to test with
@@ -2685,8 +2877,12 @@
  */
 LatLonPoint.prototype.equals = function(otherPoint) {
   return this.lat == otherPoint.lat && this.lon == otherPoint.lon;
-}
+};
 
+
+
+
+
 //////////////////////////
 //
 //  BoundingBox
@@ -2702,6 +2898,7 @@
  * @returns a new BoundingBox
  * @type BoundingBox
  * @constructor
+ * @classDescription BoundingBox
  */
 function BoundingBox(swlat, swlon, nelat, nelon) {
   //FIXME throw error if box bigger than world
@@ -2717,7 +2914,7 @@
  */
 BoundingBox.prototype.getSouthWest = function() {
   return this.sw;
-}
+};
 
 /**
  * getNorthEast returns a LatLonPoint of the north-east point of the bounding box
@@ -2726,7 +2923,7 @@
  */
 BoundingBox.prototype.getNorthEast = function() {
   return this.ne;
-}
+};
 
 /**
  * isEmpty finds if this bounding box has zero area
@@ -2735,7 +2932,7 @@
  */
 BoundingBox.prototype.isEmpty = function() {
   return this.ne == this.sw; // is this right? FIXME
-}
+};
 
 /**
  * contains finds whether a given point is within a bounding box
@@ -2744,8 +2941,8 @@
  * @type boolean
  */
 BoundingBox.prototype.contains = function(point){
-  return point.lat >= this.sw.lat && point.lat <= this.ne.lat && point.lon>= this.sw.lon && point.lon <= this.ne.lon;
-}
+  return point.lat >= this.sw.lat && point.lat <= this.ne.lat && point.lon >= this.sw.lon && point.lon <= this.ne.lon;
+};
 
 /**
  * toSpan returns a LatLonPoint with the lat and lon as the height and width of the bounding box
@@ -2754,22 +2951,26 @@
  */
 BoundingBox.prototype.toSpan = function() {
   return new LatLonPoint( Math.abs(this.sw.lat - this.ne.lat), Math.abs(this.sw.lon - this.ne.lon) );
-}
+};
+
 /**
  * extend extends the bounding box to include the new point
  */
 BoundingBox.prototype.extend = function(point) {
-    if(this.sw.lat > point.lat)
-        this.sw.lat = point.lat;
-    if(this.sw.lon > point.lon)
-        this.sw.lon = point.lon;
-    if(this.ne.lat < point.lat)
-        this.ne.lat = point.lat;
-    if(this.ne.lon < point.lon)
-        this.ne.lon = point.lon;
-        
+  if(this.sw.lat > point.lat) {
+    this.sw.lat = point.lat;
+  }   
+  if(this.sw.lon > point.lon) {
+    this.sw.lon = point.lon;
+  }   
+  if(this.ne.lat < point.lat) {
+    this.ne.lat = point.lat;
+  }   
+  if(this.ne.lon < point.lon) {
+    this.ne.lon = point.lon;
+  }
   return;
-}
+};
 
 //////////////////////////////
 //
@@ -2786,58 +2987,68 @@
   this.location = point;
   this.onmap = false;
   this.proprietary_marker = false;
-  this.attributes = new Array();
+  this.attributes = [];
   this.pinID = "mspin-"+new Date().getTime()+'-'+(Math.floor(Math.random()*Math.pow(2,16)));
 }
 
 Marker.prototype.setChild = function(some_proprietary_marker) {
   this.proprietary_marker = some_proprietary_marker;
-  this.onmap = true
-}
+  this.onmap = true;
+};
 
 Marker.prototype.setLabel = function(labelText) {
   this.labelText = labelText;
-}
+};
 
 /**
  * addData conviniently set a hash of options on a marker
  */
-  Marker.prototype.addData = function(options){
-    if(options.label)
-    this.setLabel(options.label);
-    if(options.infoBubble)
-    this.setInfoBubble(options.infoBubble);
-    if(options.icon) {
-      if(options.iconSize)
-      this.setIcon(options.icon, new Array(options.iconSize[0], options.iconSize[1]));
-      else
-      this.setIcon(options.icon);
-
-      if(options.iconAnchor)
-      this.setIconAnchor(new Array(options.iconAnchor[0], options.iconAnchor[1]));
-
+Marker.prototype.addData = function(options){
+  for(var sOptKey in options) {
+    switch(sOptKey) {
+      case 'label':
+        this.setLabel(options.label);
+        break;
+      case 'infoBubble':
+        this.setInfoBubble(options.infoBubble);
+        break;
+      case 'icon':
+        if(options.iconSize && options.iconAnchor) {
+          this.setIcon(options.icon, options.iconSize, options.iconAnchor);
+        }
+        else if(options.iconSize) {
+          this.setIcon(options.icon, options.iconSize);
+        }
+        else {
+          this.setIcon(options.icon);					
+        }
+        break;
+      case 'infoDiv':
+        this.setInfoDiv(options.infoDiv[0],options.infoDiv[1]);
+        break;
+      case 'draggable':
+        this.setDraggable(options.draggable);
+        break;
+      case 'hover':
+        this.setHover(options.hover);
+        // no break statement here intentionally
+      case 'hoverIcon':
+        this.setHoverIcon(options.hoverIcon);
+        break;
+      case 'openBubble':
+        this.openBubble();
+        break;
+      case 'groupName':
+        this.setGroupName(options.groupName);
+        break;
+      default:
+        // don't have a specific action for this bit of 
+        // data so set a named attribute
+        this.setAttribute(sOptKey, options[sOptKey]);
+        break;
     }
-    if(options.iconShadow) {
-      if(options.iconShadowSize)
-      this.setShadowIcon(options.iconShadow, new Array(options.iconShadowSize[0], options.iconShadowSize[1]));
-      else
-      this.setIcon(options.iconShadow);
-    }    
-    if(options.infoDiv)
-      this.setInfoDiv(options.infoDiv[0],options.infoDiv[1]);
-    if(options.draggable)
-      this.setDraggable(options.draggable);
-    if(options.hover)
-      this.setHover(options.hover);
-    if(options.hoverIcon)
-      this.setHoverIcon(options.hoverIcon);
-    if(options.openBubble)
-      this.openBubble();
-    if(options.date)
-      this.setAttribute( 'date', eval(options.date) );
-    if(options.category)
-      this.setAttribute( 'category', options.category );
-  }
+  }    
+};
 
 /**
  * setInfoBubble sets the html/text content for a bubble popup for a marker
@@ -2845,7 +3056,7 @@
  */
 Marker.prototype.setInfoBubble = function(infoBubble) {
   this.infoBubble = infoBubble;
-}
+};
 
 /**
  * setInfoDiv sets the text and the id of the div element where to the information
@@ -2856,49 +3067,46 @@
 Marker.prototype.setInfoDiv = function(infoDiv,div){
   this.infoDiv = infoDiv;
   this.div = div;
-}
+};
 
 /**
  * setIcon sets the icon for a marker
  * @param {String} iconUrl The URL of the image you want to be the icon
  */
-Marker.prototype.setIcon = function(iconUrl, iconSize, iconAnchor){
+Marker.prototype.setIcon = function(iconUrl, iconSize, iconAnchor) {
   this.iconUrl = iconUrl;
-    if(iconSize)
-        this.iconSize = iconSize;
-    if(iconAnchor)
-        this.iconAnchor = iconAnchor;
-        
-}
+  if(iconSize) { this.iconSize = iconSize; }
+  if(iconAnchor) { this.iconAnchor = iconAnchor; }
+};
+
 /**
  * setIconSize sets the size of the icon for a marker
  * @param {String} iconSize The array size in pixels of the marker image
  */
 Marker.prototype.setIconSize = function(iconSize){
-    if(iconSize)
-        this.iconSize = iconSize;        
-}
+  if(iconSize) { this.iconSize = iconSize; }
+};
+
 /**
  * setIconAnchor sets the anchor point for a marker
  * @param {String} iconAnchor The array offset of the anchor point
  */
 Marker.prototype.setIconAnchor = function(iconAnchor){
-    if(iconAnchor)
-        this.iconAnchor = iconAnchor;        
-}
+  if(iconAnchor) { this.iconAnchor = iconAnchor; }
+};
+
 /**
  * setShadowIcon sets the icon for a marker
  * @param {String} iconUrl The URL of the image you want to be the icon
  */
 Marker.prototype.setShadowIcon = function(iconShadowUrl, iconShadowSize){
   this.iconShadowUrl = iconShadowUrl;
-    if(iconShadowSize)
-        this.iconShadowSize = iconShadowSize;
-}
+  if(iconShadowSize) { this.iconShadowSize = iconShadowSize; }
+};
 
 Marker.prototype.setHoverIcon = function(hoverIconUrl){
   this.hoverIconUrl = hoverIconUrl;
-}
+};
 
 /**
  * setDraggable sets the draggable state of the marker
@@ -2906,7 +3114,7 @@
  */
 Marker.prototype.setDraggable = function(draggable) {
   this.draggable = draggable;
-}
+};
 
 /**
  * setHover sets that the marker info is displayed on hover
@@ -2914,26 +3122,17 @@
  */
 Marker.prototype.setHover = function(hover) {
   this.hover = hover;
-}
+};
 
-/** 
- * Dynamically changes the marker to the new icon URL
- *
-*/
-Marker.prototype.changeIcon = function(iconUrl) {
-    if (this.proprietary_marker) {
-        this.proprietary_marker.setImage(iconUrl);
-    }
-}
 /**
- * Reverts an icon back to its original icon
- * 
- * This is useful for when you change the marker and want to have it higlight on hover
-*/
-Marker.prototype.revertIcon = function() {
-    this.changeIcon(this.iconUrl);
-}
+ * Markers are grouped up by this name. declutterGroup makes use of this.
+ */
+Marker.prototype.setGroupName = function(sGrpName) {
+  this.groupName = sGrpName;
+};
 
+
+
 /**
  * toYahoo returns a Yahoo Maps compatible marker pin
  * @returns a Yahoo Maps compatible marker
@@ -2942,7 +3141,8 @@
   var ymarker;
   if(this.iconUrl) {
     ymarker = new YMarker(this.location.toYahoo (),new YImage(this.iconUrl));
-  } else {
+  } 
+  else {
     ymarker = new YMarker(this.location.toYahoo());
   }
   if(this.iconSize) {
@@ -2981,21 +3181,21 @@
   }
 
   return ymarker;
-}
+};
 
 /**
  * toGoogle returns a Google Maps compatible marker pin
  * @returns Google Maps compatible marker
  */
 Marker.prototype.toGoogle = function() {
-  var options = new Object();
-  if(this.labelText) {
-    options.title =  this.labelText;
-  }
-  if(this.iconUrl){
-    var icon = new GIcon(G_DEFAULT_ICON,this.iconUrl);
-    if(this.iconSize) {
-      icon.iconSize = new GSize(this.iconSize[0], this.iconSize[1]);
+	var options = {};
+	if(this.labelText){
+		options.title =  this.labelText;
+	}
+	if(this.iconUrl){
+		var icon = new GIcon(G_DEFAULT_ICON,this.iconUrl);
+		if(this.iconSize) {
+			icon.iconSize = new GSize(this.iconSize[0], this.iconSize[1]);
       var anchor;
       if(this.iconAnchor) {
         anchor = new GPoint(this.iconAnchor[0], this.iconAnchor[1]);                
@@ -3010,17 +3210,16 @@
       icon.shadow = this.iconShadowUrl;
       if(this.iconShadowSize) {
         icon.shadowSize = new GSize(this.iconShadowSize[0], this.iconShadowSize[1]);
-      }    
-    }    
+      }		
+    }
     options.icon = icon;
   }
   if(this.draggable){
     options.draggable = this.draggable;
   }
   var gmarker = new GMarker( this.location.toGoogle(),options);
-
-
-  if(this.infoBubble) {
+	
+  if(this.infoBubble){
     var theInfo = this.infoBubble;
     var event_action;
     if(this.hover) {
@@ -3030,19 +3229,19 @@
       event_action = "click";
     }
     GEvent.addListener(gmarker, event_action, function() {
-        gmarker.openInfoWindowHtml(theInfo, {maxWidth: 100});
-        });
+      gmarker.openInfoWindowHtml(theInfo, {maxWidth: 100});
+    });
   }
-
-  if(this.hoverIconUrl) {
+	
+  if(this.hoverIconUrl){
     GEvent.addListener(gmarker, "mouseover", function() {
-        gmarker.setImage(this.hoverIconUrl);
-        });
+      gmarker.setImage(this.hoverIconUrl);
+    });
     GEvent.addListener(gmarker, "mouseout", function() {
-        gmarker.setImage(this.iconUrl);
-        });
+      gmarker.setImage(this.iconUrl);
+    });
   }
-
+	
   if(this.infoDiv){
     var theInfo = this.infoDiv;
     var div = this.div;
@@ -3054,47 +3253,44 @@
       event_action = "click";
     }
     GEvent.addListener(gmarker, event_action, function() {
-        document.getElementById(div).innerHTML = theInfo;
-        });
+      document.getElementById(div).innerHTML = theInfo;
+    });
   }
-
+	
   return gmarker;
-}
+};
 
 /**
  * toOpenLayers returns an OpenLayers compatible marker pin
  * @returns OpenLayers compatible marker
  */
 Marker.prototype.toOpenLayers = function() {
-    
+  var size, anchor, icon;
   if(this.iconSize) {
-    var size = new OpenLayers.Size(this.iconSize[0], this.iconSize[1]);
+    size = new OpenLayers.Size(this.iconSize[0], this.iconSize[1]);
   }
-  else
-  {
-    var size = new OpenLayers.Size(15,20);
+  else {
+    size = new OpenLayers.Size(15,20);
   }
 
-  if(this.iconAnchor) 
-  {
-    var anchor = new OpenLayers.Pixel(this.iconAnchor[0], this.iconAnchor[1]);
+  if(this.iconAnchor) {
+    anchor = new OpenLayers.Pixel(this.iconAnchor[0], this.iconAnchor[1]);
   }
-  else
-  {
+  else {
     // FIXME: hard-coding the anchor point
     anchor = new OpenLayers.Pixel(-(size.w/2), -size.h);
   }
+  
   if(this.iconUrl) {
-    var icon = new OpenLayers.Icon(this.iconUrl, size, anchor);
+    icon = new OpenLayers.Icon(this.iconUrl, size, anchor);
   }
-  else
-  {
-    var icon = new OpenLayers.Icon('http://boston.openguides.org/markers/AQUA.png', size, anchor);
+  else {
+    icon = new OpenLayers.Icon('http://boston.openguides.org/markers/AQUA.png', size, anchor);
   }
 
   var marker = new OpenLayers.Marker(this.location.toOpenLayers(), icon);
   return marker;
-}
+};
 
 /**
  * toMicrosoft returns a MSFT VE compatible marker pin
@@ -3104,7 +3300,7 @@
   var pin = new VEPushpin(this.pinID,this.location.toMicrosoft(),
       this.iconUrl,this.labelText,this.infoBubble);
   return pin;
-}
+};
 
 /**
  * toMap24 returns a Map24 Location 
@@ -3112,7 +3308,7 @@
  */
 Marker.prototype.toMap24 = function() {
 
-  var ops = new Object();
+  var ops = {};
   ops.Longitude = this.location.lon*60;
   ops.Latitude = this.location.lat*60;
   if(this.infoBubble) {
@@ -3141,35 +3337,53 @@
 
   var m24Location = new Map24.Location ( ops );
   return m24Location;
-}
+};
 
 /**
  * toMultiMap returns a MultiMap compatible marker pin
  * @returns MultiMap compatible marker
  */
 Marker.prototype.toMultiMap = function() {
-  if (this.iconUrl) {
-    var icon = new MMIcon(this.iconUrl);
-    icon.iconSize = new MMDimensions(32, 32); //how to get this?
+  //prepare our markeroptions
+  var mmmarkeropts = {};
+	
+  if(this.iconUrl) {
+    mmmarkeropts.icon = new MMIcon(this.iconUrl);
+    if(this.iconSize) {
+      mmmarkeropts.icon.iconSize = new MMDimensions(this.iconSize[0], this.iconSize[1]);
+    }
+    else {
+      //mmmarkeropts.icon.iconSize = new MMDimensions(32, 32); //how to get this?
+    }
+		
+    if(this.iconAnchor) {
+      mmmarkeropts.icon.iconAnchor = new MMPoint(this.iconAnchor[0], this.iconAnchor[1]);
+    }
+		
+    if(this.groupName) {
+      mmmarkeropts.icon.groupName = this.groupName;
+    }
+  }
 
-    var mmmarker = new MMMarkerOverlay( this.location.toMultiMap(), {'icon' : icon} );
-  } else {
-    var mmmarker = new MMMarkerOverlay( this.location.toMultiMap());
+  if(this.labelText) {
+    mmmarkeropts.label = this.labelText;
   }
-  if(this.labelText){
-  }
+	
+	
+  var mmmarker = new MMMarkerOverlay( this.location.toMultiMap(), mmmarkeropts );
+  
   if(this.infoBubble) {
     mmmarker.setInfoBoxContent(this.infoBubble);
   }
-  if(this.infoDiv) {
-  }
-
+	
+  if(this.infoDiv) { }
+	
   for (var key in this.attributes) {
-    mmmarker.setAttribute(key, this.attributes[ key ]);
+    mmmarker.setAttribute(key, this.attributes[key]);
   }
-
+	
   return mmmarker;
-}
+};
 
 /**
  * toMapQuest returns a MapQuest compatible marker pin
@@ -3200,7 +3414,7 @@
   }
 
   return mqmarker;
-}
+};
 
 /**
  * toFreeEarth returns a FreeEarth compatible marker pin
@@ -3232,7 +3446,7 @@
   }
 
   return femarker;
-}
+};
 
 /**
  * setAttribute: set an arbitrary key/value pair on a marker
@@ -3241,7 +3455,7 @@
  */
 Marker.prototype.setAttribute = function(key,value) {
   this.attributes[key] = value;
-}
+};
 
 /**
  * getAttribute: gets the value of "key"
@@ -3250,7 +3464,7 @@
  */
 Marker.prototype.getAttribute = function(key) {
   return this.attributes[key];
-}
+};
 
 
 
@@ -3258,7 +3472,7 @@
  * openBubble opens the infoBubble
  */
 Marker.prototype.openBubble = function() {
-  if(this.mapstraction.loaded[this.api] == false) {
+  if(this.mapstraction.loaded[this.api] === false) {
     var my_marker = this;
     this.mapstraction.onload[this.api].push( function() { my_marker.openBubble(); } );
     return;
@@ -3288,13 +3502,13 @@
         // MapQuest hack to work around bug when opening marker
         this.proprietary_marker.setRolloverEnabled(false);
         this.proprietary_marker.showInfoWindow();
-        this.proprietary_marker.setRolloverEnabled(true);            
+        this.proprietary_marker.setRolloverEnabled(true);			
         break;
     }
   } else {
     alert('You need to add the marker before opening it');
   }
-}
+};
 
 /**
  * hide the marker
@@ -3320,13 +3534,14 @@
         break;
       case 'mapquest':
         this.proprietary_marker.setVisible(false);
-        break;                
+        break;				
       default:
-        if(this.debug)
+        if(this.debug) {
           alert(this.api + "not supported by Marker.hide");
+        }
     }
   }
-}
+};
 
 /**
  * show the marker
@@ -3352,13 +3567,14 @@
         break;
       case 'mapquest':
         this.proprietary_marker.setVisible(true);
-        break;    
+        break;	
       default:
-        if(this.debug)
+        if(this.debug) {
           alert(this.api + "not supported by Marker.show");
+        }
     }
   }
-}
+};
 
 ///////////////
 // Polyline ///
@@ -3367,7 +3583,7 @@
 
 function Polyline(points) {
   this.points = points;
-  this.attributes = new Array();
+  this.attributes = [];
   this.onmap = false;
   this.proprietary_polyline = false;
   this.pllID = "mspll-"+new Date().getTime()+'-'+(Math.floor(Math.random()*Math.pow(2,16)));
@@ -3376,40 +3592,76 @@
 /**
  * addData conviniently set a hash of options on a polyline
  */
-  Polyline.prototype.addData = function(options){
-    if(options.color)
-      this.setColor(options.color);
-    if(options.width)
-      this.setWidth(options.width); // NW corrected from setInfoBubble()
-    if(options.opacity)
-      this.setIcon(options.opacity);
-    if(options.date)
-      this.setAttribute( 'date', eval(options.date) );
-    if(options.category)
-      this.setAttribute( 'category', options.category );
+Polyline.prototype.addData = function(options){
+  for(var sOpt in options) {
+    switch(sOpt) {
+      case 'color':
+        this.setColor(options.color);
+        break;
+      case 'width':
+        this.setWidth(options.width);
+        break;
+      case 'opacity':
+        this.setOpacity(options.opacity);
+        break;
+      case 'closed':
+        this.setClosed(options.closed);
+        break;
+      case 'fillColor':
+        this.setFillColor(options.fillColor);
+        break;
+      default:
+        this.setAttribute(sOpt, options[sOpt]);
+        break;			
+    }     
   }
+};
 
 Polyline.prototype.setChild = function(some_proprietary_polyline) {
   this.proprietary_polyline = some_proprietary_polyline;
   this.onmap = true;
-}
+};
 
-//in the form: #RRGGBB
-//Note map24 insists on upper case, so we convert it.
+/**
+ * in the form: #RRGGBB
+ * Note map24 insists on upper case, so we convert it.
+ */
 Polyline.prototype.setColor = function(color){
   this.color = (color.length==7 && color[0]=="#") ? color.toUpperCase() : color;
-}
+};
 
-//An integer
+/**
+ * Stroke width of the polyline
+ * @param {Integer} width
+ */
 Polyline.prototype.setWidth = function(width){
-  this.width = width;
-}
+	this.width = width;
+};
 
-//A float between 0.0 and 1.0
+/**
+ * A float between 0.0 and 1.0
+ * @param {Float} opacity
+ */
 Polyline.prototype.setOpacity = function(opacity){
   this.opacity = opacity;
-}
+};
 
+/**
+ * Marks the polyline as a closed polygon
+ * @param {Boolean} bClosed
+ */
+Polyline.prototype.setClosed = function(bClosed){
+  this.closed = bClosed;
+};
+
+/**
+ * Fill color for a closed polyline as HTML color value e.g. #RRGGBB
+ * @param {String} sFillColor HTML color value #RRGGBB
+ */
+Polyline.prototype.setFillColor = function(sFillColor) {
+	this.fillColor = sFillColor;
+};
+
 Polyline.prototype.toYahoo = function() {
   var ypolyline;
   var ypoints = [];
@@ -3418,7 +3670,7 @@
   }
   ypolyline = new YPolyline(ypoints,this.color,this.width,this.opacity);
   return ypolyline;
-}
+};
 
 Polyline.prototype.toGoogle = function() {
   var gpolyline;
@@ -3428,7 +3680,7 @@
   }
   gpolyline = new GPolyline(gpoints,this.color,this.width,this.opacity);
   return gpolyline;
-}
+};
 
 Polyline.prototype.toMap24 = function() {
   var m24polyline;
@@ -3444,13 +3696,13 @@
   }
 
   m24polyline = new Map24.Polyline({
-Longitudes: m24longs,
-Latitudes: m24lats,
-Color: this.color || "black",
-Width: this.width || 3
-});
-return m24polyline;
-}
+    Longitudes: m24longs,
+    Latitudes: m24lats,
+    Color: this.color || "black",
+    Width: this.width || 3
+  });
+  return m24polyline;
+};
 
 Polyline.prototype.toMicrosoft = function() {
   var mpolyline;
@@ -3469,7 +3721,7 @@
 
   mpolyline = new VEPolyline(this.pllID,mpoints,color,this.width);
   return mpolyline;
-}
+};
 
 Polyline.prototype.toMultiMap = function() {
   var mmpolyline;
@@ -3477,9 +3729,9 @@
   for (var i = 0, length = this.points.length ; i< length; i++){
     mmpoints.push(this.points[i].toMultiMap());
   }
-  mmpolyline = new MMPolyLineOverlay(mmpoints, this.color, this.opacity, this.width, false, undefined);
+  mmpolyline = new MMPolyLineOverlay(mmpoints, this.color, this.opacity, this.width, this.closed, this.fillColor);
   return mmpolyline;
-}
+};
 
 Polyline.prototype.toMapQuest = function() {
   var mqpolyline = new MQLineOverlay();
@@ -3494,9 +3746,10 @@
   }
   mqpolyline.setShapePoints(mqpoints);
   return mqpolyline;
-}
+};
+
 Polyline.prototype.toFreeEarth = function() {
-  var fepoints = new Array();
+  var fepoints = [];
 
   for (var i = 0, length = this.points.length ; i< length; i++){
     fepoints.push(this.points[i].toFreeEarth());
@@ -3505,7 +3758,7 @@
   var fepolyline = new FE.Polyline(fepoints, this.color || '0xff0000', this.width || 1, this.opacity || 1);
 
   return fepolyline;
-}
+};
 
 /**
  * setAttribute: set an arbitrary key/value pair on a polyline
@@ -3514,7 +3767,7 @@
  */
 Polyline.prototype.setAttribute = function(key,value) {
   this.attributes[key] = value;
-}
+};
 
 /**
  * getAttribute: gets the value of "key"
@@ -3523,23 +3776,44 @@
  */
 Polyline.prototype.getAttribute = function(key) {
   return this.attributes[key];
-}
+};
 
 /**
  * show: not yet implemented
  */
 Polyline.prototype.show = function() {
-  if (this.api) {
+  switch (this.api) {
+    case 'multimap':
+      if(!this.onmap) {
+        this.map.addOverlay(this.proprietary_polyline);
+      }
+      break;
+    default:
+      if(this.debug) {
+        alert(api + ' not supported by Polyline.show');
+      }
+      break;
   }
-}
+};
 
 /**
  * hide: not yet implemented
  */
 Polyline.prototype.hide = function() {
-  if (this.api) {
+  switch (this.api) {
+    case 'multimap':
+      if(this.onmap) {
+        this.map.removeOverlay(this.proprietary_polyline);
+        this.onmap = false;
+      }
+      break;
+    default:
+      if(this.debug) {
+        alert(api + ' not supported by Polyline.hide');
+      }
+      break;
   }
-}
+};
 
 /////////////
 /// Route ///
@@ -3551,20 +3825,63 @@
  * @params {Object} route The route object returned in the callback from MapstractionRouter
  */
 Mapstraction.prototype.showRoute = function(route) { 
-  if(this.loaded[this.api] == false) {
-    myself = this;
-    this.onload[this.api].push( function() { myself.showRoute(route); } );
+  if(this.loaded[this.api] === false) {
+    self = this;
+    this.onload[this.api].push( function() { self.showRoute(route); } );
     return;
-  }    
+  }	
   var map = this.maps[this.api];
   switch (this.api) {
     case 'mapquest':
-      map.addRouteHighlight(route['bounding_box'],"http://map.access.mapquest.com",route['session_id'],true);
+      map.addRouteHighlight(route['bounding_box'], "http://map.access.mapquest.com", route['session_id'], true);
       break;
     default:
-      if(this.debug)
+      if(this.debug) {
         alert(api + ' not supported by Mapstration.showRoute');
+      }
       break;
   }
-}
+};
 
+
+/*
+ * Expose mapstraction through mxn namespace
+ */
+window.mxn = {
+  'BoundingBox': BoundingBox,
+  'LatLonPoint': LatLonPoint,
+  'Mapstraction': Mapstraction,
+  'Marker': Marker,
+  'Polyline': Polyline,
+  
+  /*
+   * Expose utility functions to the outside
+   */
+  'fn': {
+    'metresToLon': metresToLon,
+    'lonToMetres': lonToMetres,
+    'loadScript': loadScript
+  },
+  
+  /**
+   * Allow spillage of classes for backward compatibility with 
+   * non-namespaced versions. NOTE: Doesn't expose loose utility 
+   * functions.
+   */
+  activatePolluteMode: function(){
+    if(
+      window.BoundingBox || 
+      window.LatLonPoint ||
+      window.Mapstraction ||
+      window.Marker || 
+      window.Polyline
+    ) { alert('Warning: Mapstraction polute mode naming clash.'); }
+    window['BoundingBox'] = BoundingBox;
+    window['LatLonPoint'] = LatLonPoint;
+    window['Mapstraction'] = Mapstraction;
+    window['Marker'] = Marker;
+    window['Polyline'] = Polyline;
+  }
+};
+
+})();
